CCS PCH C Compiler, Version 5.093, 4770               09-Dec-24 23:27

               Filename:   C:\Users\titor\Downloads\Proy SD\Prueba Ccs.lst

               ROM used:   5002 bytes (15%)
                           Largest free fragment is 27766
               RAM used:   227 (11%) at main() level
                           398 (19%) worst case
               Stack used: 0 locations
               Stack size: 31

0000:  GOTO   116C
.................... #include <18f4550.h>
.................... //////////// Standard Header file for the PIC18F4550 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F4550
0004:  CLRF   FF7
0006:  ADDLW  14
0008:  MOVWF  FF6
000A:  MOVLW  00
000C:  ADDWFC FF7,F
000E:  TBLRD*+
0010:  MOVF   FF5,W
0012:  RETURN 0
0014:  DATA 00,00
0016:  DATA 00,00
0018:  DATA 00,00
001A:  DATA 00,5F
001C:  DATA 00,00
001E:  DATA 00,03
0020:  DATA 00,03
0022:  DATA 00,14
0024:  DATA 3E,14
0026:  DATA 3E,14
0028:  DATA 24,2A
002A:  DATA 7F,2A
002C:  DATA 12,43
002E:  DATA 33,08
0030:  DATA 66,61
0032:  DATA 36,49
0034:  DATA 55,22
0036:  DATA 50,00
0038:  DATA 05,03
003A:  DATA 00,00
003C:  DATA 00,1C
003E:  DATA 22,41
0040:  DATA 00,00
0042:  DATA 41,22
0044:  DATA 1C,00
0046:  DATA 14,08
0048:  DATA 3E,08
004A:  DATA 14,08
004C:  DATA 08,3E
004E:  DATA 08,08
0050:  DATA 00,50
0052:  DATA 30,00
0054:  DATA 00,08
0056:  DATA 08,08
0058:  DATA 08,08
005A:  DATA 00,60
005C:  DATA 60,00
005E:  DATA 00,20
0060:  DATA 10,08
0062:  DATA 04,02
0064:  DATA 3E,51
0066:  DATA 49,45
0068:  DATA 3E,00
006A:  DATA 04,02
006C:  DATA 7F,00
006E:  DATA 42,61
0070:  DATA 51,49
0072:  DATA 46,22
0074:  DATA 41,49
0076:  DATA 49,36
0078:  DATA 18,14
007A:  DATA 12,7F
007C:  DATA 10,27
007E:  DATA 45,45
0080:  DATA 45,39
0082:  DATA 3E,49
0084:  DATA 49,49
0086:  DATA 32,01
0088:  DATA 01,71
008A:  DATA 09,07
008C:  DATA 36,49
008E:  DATA 49,49
0090:  DATA 36,26
0092:  DATA 49,49
0094:  DATA 49,3E
0096:  DATA 00,36
0098:  DATA 36,00
009A:  DATA 00,00
009C:  DATA 56,36
009E:  DATA 00,00
00A0:  DATA 08,14
00A2:  DATA 22,41
00A4:  DATA 00,14
00A6:  DATA 14,14
00A8:  DATA 14,14
00AA:  DATA 00,41
00AC:  DATA 22,14
00AE:  DATA 08,02
00B0:  DATA 01,51
00B2:  DATA 09,06
00B4:  DATA 3E,41
00B6:  DATA 59,55
00B8:  DATA 5E,7E
00BA:  DATA 09,09
00BC:  DATA 09,7E
00BE:  DATA 7F,49
00C0:  DATA 49,49
00C2:  DATA 36,3E
00C4:  DATA 41,41
00C6:  DATA 41,22
00C8:  DATA 7F,41
00CA:  DATA 41,41
00CC:  DATA 3E,7F
00CE:  DATA 49,49
00D0:  DATA 49,41
00D2:  DATA 7F,09
00D4:  DATA 09,09
00D6:  DATA 01,3E
00D8:  DATA 41,41
00DA:  DATA 49,3A
00DC:  DATA 7F,08
00DE:  DATA 08,08
00E0:  DATA 7F,00
00E2:  DATA 41,7F
00E4:  DATA 41,00
00E6:  DATA 30,40
00E8:  DATA 40,40
00EA:  DATA 3F,7F
00EC:  DATA 08,14
00EE:  DATA 22,41
00F0:  DATA 7F,40
00F2:  DATA 40,40
00F4:  DATA 40,7F
00F6:  DATA 02,0C
00F8:  DATA 02,7F
00FA:  DATA 7F,02
00FC:  DATA 04,08
00FE:  DATA 7F,3E
0100:  DATA 41,41
0102:  DATA 41,3E
0104:  DATA 7F,09
0106:  DATA 09,09
0108:  DATA 06,1E
010A:  DATA 21,21
010C:  DATA 21,5E
010E:  DATA 7F,09
0110:  DATA 09,09
0112:  DATA 76,00
0114:  CLRF   FF7
0116:  ADDLW  24
0118:  MOVWF  FF6
011A:  MOVLW  01
011C:  ADDWFC FF7,F
011E:  TBLRD*+
0120:  MOVF   FF5,W
0122:  RETURN 0
0124:  DATA 26,49
0126:  DATA 49,49
0128:  DATA 32,01
012A:  DATA 01,7F
012C:  DATA 01,01
012E:  DATA 3F,40
0130:  DATA 40,40
0132:  DATA 3F,1F
0134:  DATA 20,40
0136:  DATA 20,1F
0138:  DATA 7F,20
013A:  DATA 10,20
013C:  DATA 7F,41
013E:  DATA 22,1C
0140:  DATA 22,41
0142:  DATA 07,08
0144:  DATA 70,08
0146:  DATA 07,61
0148:  DATA 51,49
014A:  DATA 45,43
014C:  DATA 00,7F
014E:  DATA 41,00
0150:  DATA 00,02
0152:  DATA 04,08
0154:  DATA 10,20
0156:  DATA 00,00
0158:  DATA 41,7F
015A:  DATA 00,04
015C:  DATA 02,01
015E:  DATA 02,04
0160:  DATA 40,40
0162:  DATA 40,40
0164:  DATA 40,00
0166:  DATA 01,02
0168:  DATA 04,00
016A:  DATA 20,54
016C:  DATA 54,54
016E:  DATA 78,7F
0170:  DATA 44,44
0172:  DATA 44,38
0174:  DATA 38,44
0176:  DATA 44,44
0178:  DATA 44,38
017A:  DATA 44,44
017C:  DATA 44,7F
017E:  DATA 38,54
0180:  DATA 54,54
0182:  DATA 18,04
0184:  DATA 04,7E
0186:  DATA 05,05
0188:  DATA 08,54
018A:  DATA 54,54
018C:  DATA 3C,7F
018E:  DATA 08,04
0190:  DATA 04,78
0192:  DATA 00,44
0194:  DATA 7D,40
0196:  DATA 00,20
0198:  DATA 40,44
019A:  DATA 3D,00
019C:  DATA 7F,10
019E:  DATA 28,44
01A0:  DATA 00,00
01A2:  DATA 41,7F
01A4:  DATA 40,00
01A6:  DATA 7C,04
01A8:  DATA 78,04
01AA:  DATA 78,7C
01AC:  DATA 08,04
01AE:  DATA 04,78
01B0:  DATA 38,44
01B2:  DATA 44,44
01B4:  DATA 38,7C
01B6:  DATA 14,14
01B8:  DATA 14,08
01BA:  DATA 08,14
01BC:  DATA 14,14
01BE:  DATA 7C,00
01C0:  DATA 7C,08
01C2:  DATA 04,04
01C4:  DATA 48,54
01C6:  DATA 54,54
01C8:  DATA 20,04
01CA:  DATA 04,3F
01CC:  DATA 44,44
01CE:  DATA 3C,40
01D0:  DATA 40,20
01D2:  DATA 7C,1C
01D4:  DATA 20,40
01D6:  DATA 20,1C
01D8:  DATA 3C,40
01DA:  DATA 30,40
01DC:  DATA 3C,44
01DE:  DATA 28,10
01E0:  DATA 28,44
01E2:  DATA 0C,50
01E4:  DATA 50,50
01E6:  DATA 3C,44
01E8:  DATA 64,54
01EA:  DATA 4C,44
01EC:  DATA 00,08
01EE:  DATA 36,41
01F0:  DATA 41,00
01F2:  DATA 00,7F
01F4:  DATA 00,00
01F6:  DATA 41,41
01F8:  DATA 36,08
01FA:  DATA 00,02
01FC:  DATA 01,02
01FE:  DATA 04,02
0200:  CLRF   FF7
0202:  ADDLW  10
0204:  MOVWF  FF6
0206:  MOVLW  02
0208:  ADDWFC FF7,F
020A:  TBLRD*+
020C:  MOVF   FF5,W
020E:  RETURN 0
0210:  DATA 31,32
0212:  DATA 33,41
0214:  DATA 34,35
0216:  DATA 36,42
0218:  DATA 37,38
021A:  DATA 39,43
021C:  DATA 2A,30
021E:  DATA 23,44
*
0716:  ADDWF  FE8,W
0718:  CLRF   FF7
071A:  RLCF   FF7,F
071C:  ADDLW  31
071E:  MOVWF  FF6
0720:  MOVLW  07
0722:  ADDWFC FF7,F
0724:  TBLRD*-
0726:  MOVF   FF5,W
0728:  MOVWF  FFA
072A:  TBLRD*
072C:  MOVF   FF5,W
072E:  MOVWF  FF9
0730:  DATA 62,06
0732:  DATA 6C,06
0734:  DATA 76,06
0736:  DATA 80,06
*
07B0:  CLRF   00
07B2:  CLRF   01
07B4:  MOVLB  1
07B6:  MOVF   x68,W
07B8:  BCF    FD8.0
07BA:  BTFSC  x69.0
07BC:  ADDWF  00,F
07BE:  RRCF   00,F
07C0:  RRCF   01,F
07C2:  BTFSC  x69.1
07C4:  ADDWF  00,F
07C6:  RRCF   00,F
07C8:  RRCF   01,F
07CA:  BTFSC  x69.2
07CC:  ADDWF  00,F
07CE:  RRCF   00,F
07D0:  RRCF   01,F
07D2:  BTFSC  x69.3
07D4:  ADDWF  00,F
07D6:  RRCF   00,F
07D8:  RRCF   01,F
07DA:  BTFSC  x69.4
07DC:  ADDWF  00,F
07DE:  RRCF   00,F
07E0:  RRCF   01,F
07E2:  BTFSC  x69.5
07E4:  ADDWF  00,F
07E6:  RRCF   00,F
07E8:  RRCF   01,F
07EA:  BTFSC  x69.6
07EC:  ADDWF  00,F
07EE:  RRCF   00,F
07F0:  RRCF   01,F
07F2:  BTFSC  x69.7
07F4:  ADDWF  00,F
07F6:  RRCF   00,F
07F8:  RRCF   01,F
07FA:  MOVLB  0
07FC:  GOTO   08D0 (RETURN)
.................... 
.................... #list
.................... 
.................... #use delay(clock=8Mhz)
*
0BBA:  MOVLW  01
0BBC:  MOVWF  FEA
0BBE:  MOVLW  62
0BC0:  MOVWF  FE9
0BC2:  MOVF   FEF,W
0BC4:  BZ    0BE0
0BC6:  MOVLW  02
0BC8:  MOVWF  01
0BCA:  CLRF   00
0BCC:  DECFSZ 00,F
0BCE:  BRA    0BCC
0BD0:  DECFSZ 01,F
0BD2:  BRA    0BCA
0BD4:  MOVLW  97
0BD6:  MOVWF  00
0BD8:  DECFSZ 00,F
0BDA:  BRA    0BD8
0BDC:  DECFSZ FEF,F
0BDE:  BRA    0BC6
0BE0:  RETURN 0
.................... #include <hdm64gs12.c> // Libreria MANEJO LCD GRAFICO (lcdg)
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                           HDM64GS12.c                           ////
.................... ////                                                                 ////
.................... //// This file contains drivers for using a Hantronix HDM64GS12 with ////
.................... //// a KS0108 display controller. The HDM64GS12 is 128 by 64 pixels. ////
.................... //// The driver treats the upper left pixel as (0,0).                ////
.................... ////                                                                 ////
.................... //// Use #define FAST_GLCD if the target chip has at least 1k of RAM ////
.................... //// to decrease the time it takes to update the display.            ////
.................... //// glcd_update() must then be called to update the display after   ////
.................... //// changing the pixel information.                                 ////
.................... //// See ex_glcd.c for suggested usage.                              ////
.................... //// See KS0108.c for controlling a single 64 by 64 display          ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... //// LCD Pin connections:                                            ////
.................... //// (These can be changed as needed in the following defines).      ////
.................... ////  * 1: VSS is connected to GND                                   ////
.................... ////  * 2: VDD is connected to +5V                                   ////
.................... ////  * 3: V0  - LCD operating voltage (Constrast adjustment)        ////
.................... ////  * 4: D/I - Data or Instruction is connected to B2              ////
.................... ////  * 5: R/W - Read or Write is connected to B4                    ////
.................... ////  * 6: Enable is connected to B5                                 ////
.................... ////  *7-14: Data Bus 0 to 7 is connected to port d                  ////
.................... ////  *15: Chip Select 1 is connected to B0                          ////
.................... ////  *16: Chip Select 2 is connected to B1                          ////
.................... ////  *17: Reset is connected to C0                                  ////
.................... ////  *18: Negative voltage is also connected to the 20k Ohm POT     ////
.................... ////  *19: Positive voltage for LED backlight is connected to +5V    ////
.................... ////  *20: Negavtive voltage for LED backlight is connected to GND   ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... ////  glcd_init(mode)                                                ////
.................... ////     * Must be called before any other function.                 ////
.................... ////       - mode can be ON or OFF to turn the LCD on or off         ////
.................... ////                                                                 ////
.................... ////  glcd_pixel(x,y,color)                                          ////
.................... ////     * Sets the pixel to the given color.                        ////
.................... ////       - color can be ON or OFF                                  ////
.................... ////                                                                 ////
.................... ////  glcd_fillScreen(color)                                         ////
.................... ////     * Fills the entire LCD with the given color.                ////
.................... ////       - color can be ON or OFF                                  ////
.................... ////                                                                 ////
.................... ////  glcd_update()                                                  ////
.................... ////     * Write the display data stored in RAM to the LCD           ////
.................... ////     * Only available if FAST_GLCD is defined                    ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2004 Custom Computer Services        ////
.................... //// This source code may only be used by licensed users of the CCS  ////
.................... //// C compiler.  This source code may only be distributed to other  ////
.................... //// licensed users of the CCS C compiler.  No other use,            ////
.................... //// reproduction or distribution is permitted without written       ////
.................... //// permission.  Derivative programs created using this software    ////
.................... //// in object code form are not restricted in any way.              ////
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... 
.................... #ifndef HDM64GS12
.................... #define HDM64GS12
.................... 
.................... #ifndef GLCD_WIDTH
.................... #define GLCD_WIDTH   128
.................... #endif
.................... 
.................... #ifndef GLCD_CS1
.................... #define GLCD_CS1     PIN_A0   // Chip Selection 1
.................... #endif
.................... 
.................... #ifndef GLCD_CS2
.................... #define GLCD_CS2     PIN_A1   // Chip Selection 2
.................... #endif
.................... 
.................... #ifndef GLCD_DI
.................... #define GLCD_DI      PIN_A2   // Data or Instruction input
.................... #endif
.................... 
.................... #ifndef GLCD_RW
.................... #define GLCD_RW      PIN_A3   // Read/Write
.................... #endif
.................... 
.................... #ifndef GLCD_E
.................... #define GLCD_E       PIN_A4   // Enable
.................... #endif
.................... 
.................... #ifndef GLCD_RST
.................... #define GLCD_RST     PIN_C0   // Reset
.................... #endif
.................... 
.................... #define GLCD_LEFT    0
.................... #define GLCD_RIGHT   1
.................... 
.................... #ifndef ON
.................... #define ON           1
.................... #endif
.................... 
.................... #ifndef OFF
.................... #define OFF          0
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////
.................... // Function Prototypes
.................... /////////////////////////////////////////////////////////////////////////
.................... void glcd_init(int1 mode);
.................... void glcd_pixel(unsigned int8 x, unsigned int8 y, int1 color);
.................... void glcd_fillScreen(int1 color);
.................... void glcd_writeByte(int1 side, BYTE data);
.................... BYTE glcd_readByte(int1 side);
.................... void glcd_update();
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifdef FAST_GLCD
.................... struct
.................... {
....................    unsigned int8 left[512];
....................    unsigned int8 right[512];
.................... } displayData;
.................... #endif
.................... 
.................... 
.................... // Purpose:       Initialize the LCD.
.................... //                Call before using any other LCD function.
.................... // Inputs:        OFF - Turns the LCD off
.................... //                ON  - Turns the LCD on
.................... void glcd_init(int1 mode)
.................... {
....................    // Initialze some pins
....................    output_high(GLCD_RST);
*
02E2:  BCF    F94.0
02E4:  BSF    F8B.0
....................    output_low(GLCD_E);
02E6:  BCF    F92.4
02E8:  BCF    F89.4
....................    output_low(GLCD_CS1);
02EA:  BCF    F92.0
02EC:  BCF    F89.0
....................    output_low(GLCD_CS2);
02EE:  BCF    F92.1
02F0:  BCF    F89.1
.................... 
....................    output_low(GLCD_DI);                 // Set for instruction
02F2:  BCF    F92.2
02F4:  BCF    F89.2
....................    glcd_writeByte(GLCD_LEFT,  0xC0);    // Specify first RAM line at the top
02F6:  MOVLB  1
02F8:  CLRF   x7F
02FA:  MOVLW  C0
02FC:  MOVWF  x80
02FE:  MOVLB  0
0300:  RCALL  0224
....................    glcd_writeByte(GLCD_RIGHT, 0xC0);    //   of the screen
0302:  MOVLW  01
0304:  MOVLB  1
0306:  MOVWF  x7F
0308:  MOVLW  C0
030A:  MOVWF  x80
030C:  MOVLB  0
030E:  RCALL  0224
....................    glcd_writeByte(GLCD_LEFT,  0x40);    // Set the column address to 0
0310:  MOVLB  1
0312:  CLRF   x7F
0314:  MOVLW  40
0316:  MOVWF  x80
0318:  MOVLB  0
031A:  RCALL  0224
....................    glcd_writeByte(GLCD_RIGHT, 0x40);
031C:  MOVLW  01
031E:  MOVLB  1
0320:  MOVWF  x7F
0322:  MOVLW  40
0324:  MOVWF  x80
0326:  MOVLB  0
0328:  RCALL  0224
....................    glcd_writeByte(GLCD_LEFT,  0xB8);    // Set the page address to 0
032A:  MOVLB  1
032C:  CLRF   x7F
032E:  MOVLW  B8
0330:  MOVWF  x80
0332:  MOVLB  0
0334:  RCALL  0224
....................    glcd_writeByte(GLCD_RIGHT, 0xB8);
0336:  MOVLW  01
0338:  MOVLB  1
033A:  MOVWF  x7F
033C:  MOVLW  B8
033E:  MOVWF  x80
0340:  MOVLB  0
0342:  RCALL  0224
.................... 
....................    if(mode == ON)
0344:  DECFSZ xE2,W
0346:  BRA    0364
....................    {
....................       glcd_writeByte(GLCD_LEFT,  0x3F); // Turn the display on
0348:  MOVLB  1
034A:  CLRF   x7F
034C:  MOVLW  3F
034E:  MOVWF  x80
0350:  MOVLB  0
0352:  RCALL  0224
....................       glcd_writeByte(GLCD_RIGHT, 0x3F);
0354:  MOVLW  01
0356:  MOVLB  1
0358:  MOVWF  x7F
035A:  MOVLW  3F
035C:  MOVWF  x80
035E:  MOVLB  0
0360:  RCALL  0224
....................    }
0362:  BRA    037E
....................    else
....................    {
....................       glcd_writeByte(GLCD_LEFT,  0x3E); // Turn the display off
0364:  MOVLB  1
0366:  CLRF   x7F
0368:  MOVLW  3E
036A:  MOVWF  x80
036C:  MOVLB  0
036E:  RCALL  0224
....................       glcd_writeByte(GLCD_RIGHT, 0x3E);
0370:  MOVLW  01
0372:  MOVLB  1
0374:  MOVWF  x7F
0376:  MOVLW  3E
0378:  MOVWF  x80
037A:  MOVLB  0
037C:  RCALL  0224
....................    }
.................... 
....................    glcd_fillScreen(OFF);                // Clear the display
037E:  MOVLB  1
0380:  CLRF   x61
0382:  MOVLB  0
0384:  RCALL  025C
.................... 
....................    #ifdef FAST_GLCD
0386:  GOTO   122A (RETURN)
....................    glcd_update();
....................    #endif
.................... }
.................... 
.................... 
.................... // Purpose:    Update the LCD with data from the display arrays
.................... #ifdef FAST_GLCD
.................... void glcd_update()
.................... {
....................    unsigned int8 i, j;
....................    unsigned int8 *p1, *p2;
.................... 
....................    p1 = displayData.left;
....................    p2 = displayData.right;
.................... 
....................    // Loop through the vertical pages
....................    for(i = 0; i < 8; ++i)
....................    {
....................       output_low(GLCD_DI);                      // Set for instruction
....................       glcd_writeByte(GLCD_LEFT, 0x40);          // Set horizontal address to 0
....................       glcd_writeByte(GLCD_RIGHT, 0x40);
....................       glcd_writeByte(GLCD_LEFT, i | 0xB8);      // Set page address
....................       glcd_writeByte(GLCD_RIGHT, i | 0xB8);
....................       output_high(GLCD_DI);                     // Set for data
.................... 
....................       // Loop through the horizontal sections
....................       for(j = 0; j < 64; ++j)
....................       {
....................          glcd_writeByte(GLCD_LEFT, *p1++);      // Turn pixels on or off
....................          glcd_writeByte(GLCD_RIGHT, *p2++);     // Turn pixels on or off
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... 
.................... // Purpose:    Turn a pixel on a graphic LCD on or off
.................... // Inputs:     1) x - the x coordinate of the pixel
.................... //             2) y - the y coordinate of the pixel
.................... //             3) color - ON or OFF
.................... void glcd_pixel(unsigned int8 x, unsigned int8 y, int1 color)
.................... #ifdef FAST_GLCD
*
03C4:  MOVLB  1
03C6:  BCF    x7C.0
.................... {
....................    unsigned int8* p;
....................    unsigned int16 temp;
....................    temp =  y/8;
....................    temp *= 64;
....................    temp += x;
.................... 
....................    if(x > 63)
....................    {
....................       p = displayData.right + temp - 64;
....................    }
....................    else
....................    {
....................       p = displayData.left + temp;
....................    }
.................... 
....................    if(color)
....................    {
....................       bit_set(*p, y%8);
....................    }
....................    else
....................    {
....................       bit_clear(*p, y%8);
....................    }
.................... }
.................... #else
.................... {
....................    BYTE data;
....................    int1 side = GLCD_LEFT;  // Stores which chip to use on the LCD
.................... 
....................    if(x > 63)              // Check for first or second display area
03C8:  MOVF   x78,W
03CA:  SUBLW  3F
03CC:  BC    03D4
....................    {
....................       x -= 64;
03CE:  MOVLW  40
03D0:  SUBWF  x78,F
....................       side = GLCD_RIGHT;
03D2:  BSF    x7C.0
....................    }
.................... 
....................    output_low(GLCD_DI);                         // Set for instruction
03D4:  BCF    F92.2
03D6:  BCF    F89.2
....................    bit_clear(x,7);                              // Clear the MSB. Part of an instruction code
03D8:  BCF    x78.7
....................    bit_set(x,6);                                // Set bit 6. Also part of an instruction code
03DA:  BSF    x78.6
....................    glcd_writeByte(side, x);                     // Set the horizontal address
03DC:  MOVLW  00
03DE:  BTFSC  x7C.0
03E0:  MOVLW  01
03E2:  MOVWF  x7D
03E4:  MOVWF  x7F
03E6:  MOVFF  178,180
03EA:  MOVLB  0
03EC:  RCALL  0224
....................    glcd_writeByte(side, (y/8 & 0xBF) | 0xB8);   // Set the vertical page address
03EE:  MOVLW  00
03F0:  MOVLB  1
03F2:  BTFSC  x7C.0
03F4:  MOVLW  01
03F6:  MOVWF  x7D
03F8:  RRCF   x79,W
03FA:  MOVWF  00
03FC:  RRCF   00,F
03FE:  RRCF   00,F
0400:  MOVLW  1F
0402:  ANDWF  00,F
0404:  MOVF   00,W
0406:  ANDLW  BF
0408:  IORLW  B8
040A:  MOVWF  x7E
040C:  MOVFF  17D,17F
0410:  MOVWF  x80
0412:  MOVLB  0
0414:  RCALL  0224
....................    output_high(GLCD_DI);                        // Set for data
0416:  BCF    F92.2
0418:  BSF    F89.2
....................    glcd_readByte(side);                         // Need two reads to get data
041A:  MOVLW  00
041C:  MOVLB  1
041E:  BTFSC  x7C.0
0420:  MOVLW  01
0422:  MOVWF  x7D
0424:  MOVWF  x7E
0426:  MOVLB  0
0428:  RCALL  038A
....................    data = glcd_readByte(side);                  //  at new address
042A:  MOVLW  00
042C:  MOVLB  1
042E:  BTFSC  x7C.0
0430:  MOVLW  01
0432:  MOVWF  x7D
0434:  MOVWF  x7E
0436:  MOVLB  0
0438:  RCALL  038A
043A:  MOVFF  01,17B
.................... 
....................    if(color == ON)
043E:  MOVLB  1
0440:  DECFSZ x7A,W
0442:  BRA    0462
....................       bit_set(data, y%8);        // Turn the pixel on
0444:  MOVF   x79,W
0446:  ANDLW  07
0448:  MOVWF  x7D
044A:  MOVLW  01
044C:  MOVWF  00
044E:  MOVF   x7D,W
0450:  MOVWF  01
0452:  BZ    045C
0454:  BCF    FD8.0
0456:  RLCF   00,F
0458:  DECFSZ 01,F
045A:  BRA    0454
045C:  MOVF   00,W
045E:  IORWF  x7B,F
0460:  BRA    0480
....................    else                          // or
....................       bit_clear(data, y%8);      // turn the pixel off
0462:  MOVF   x79,W
0464:  ANDLW  07
0466:  MOVWF  x7D
0468:  MOVLW  01
046A:  MOVWF  00
046C:  MOVF   x7D,W
046E:  MOVWF  01
0470:  BZ    047A
0472:  BCF    FD8.0
0474:  RLCF   00,F
0476:  DECFSZ 01,F
0478:  BRA    0472
047A:  MOVF   00,W
047C:  XORLW  FF
047E:  ANDWF  x7B,F
.................... 
....................    output_low(GLCD_DI);          // Set for instruction
0480:  BCF    F92.2
0482:  BCF    F89.2
....................    glcd_writeByte(side, x);      // Set the horizontal address
0484:  MOVLW  00
0486:  BTFSC  x7C.0
0488:  MOVLW  01
048A:  MOVWF  x7D
048C:  MOVWF  x7F
048E:  MOVFF  178,180
0492:  MOVLB  0
0494:  RCALL  0224
....................    output_high(GLCD_DI);         // Set for data
0496:  BCF    F92.2
0498:  BSF    F89.2
....................    glcd_writeByte(side, data);   // Write the pixel data
049A:  MOVLW  00
049C:  MOVLB  1
049E:  BTFSC  x7C.0
04A0:  MOVLW  01
04A2:  MOVWF  x7D
04A4:  MOVWF  x7F
04A6:  MOVFF  17B,180
04AA:  MOVLB  0
04AC:  RCALL  0224
04AE:  GOTO   0620 (RETURN)
.................... }
.................... #endif
.................... 
.................... 
.................... // Purpose:    Fill the LCD screen with the passed in color
.................... // Inputs:     ON  - turn all the pixels on
.................... //             OFF - turn all the pixels off
.................... void glcd_fillScreen(int1 color)
.................... #ifdef FAST_GLCD
.................... {
....................    unsigned int8  data;
....................    unsigned int8  *p1, *p2;
....................    unsigned int16 i;
.................... 
....................    p1 = displayData.left;
....................    p2 = displayData.right;
....................    data = 0xFF * color;
.................... 
....................    for(i=0; i<512; ++i)
....................    {
....................       *p1++ = data;
....................       *p2++ = data;
....................    }
.................... }
.................... #else
.................... {
....................    unsigned int8 i, j;
.................... 
....................    // Loop through the vertical pages
....................    for(i = 0; i < 8; ++i)
*
025C:  MOVLB  1
025E:  CLRF   x62
0260:  MOVF   x62,W
0262:  SUBLW  07
0264:  BNC   02DE
....................    {
....................       output_low(GLCD_DI);                      // Set for instruction
0266:  BCF    F92.2
0268:  BCF    F89.2
....................       glcd_writeByte(GLCD_LEFT, 0b01000000);    // Set horizontal address to 0
026A:  CLRF   x7F
026C:  MOVLW  40
026E:  MOVWF  x80
0270:  MOVLB  0
0272:  RCALL  0224
....................       glcd_writeByte(GLCD_RIGHT, 0b01000000);
0274:  MOVLW  01
0276:  MOVLB  1
0278:  MOVWF  x7F
027A:  MOVLW  40
027C:  MOVWF  x80
027E:  MOVLB  0
0280:  RCALL  0224
....................       glcd_writeByte(GLCD_LEFT, i | 0b10111000);// Set page address
0282:  MOVLB  1
0284:  MOVF   x62,W
0286:  IORLW  B8
0288:  MOVWF  x64
028A:  CLRF   x7F
028C:  MOVWF  x80
028E:  MOVLB  0
0290:  RCALL  0224
....................       glcd_writeByte(GLCD_RIGHT, i | 0b10111000);
0292:  MOVLB  1
0294:  MOVF   x62,W
0296:  IORLW  B8
0298:  MOVWF  x64
029A:  MOVLW  01
029C:  MOVWF  x7F
029E:  MOVFF  164,180
02A2:  MOVLB  0
02A4:  RCALL  0224
....................       output_high(GLCD_DI);                     // Set for data
02A6:  BCF    F92.2
02A8:  BSF    F89.2
.................... 
....................       // Loop through the horizontal sections
....................       for(j = 0; j < 64; ++j)
02AA:  MOVLB  1
02AC:  CLRF   x63
02AE:  MOVF   x63,W
02B0:  SUBLW  3F
02B2:  BNC   02DA
....................       {
....................          glcd_writeByte(GLCD_LEFT, 0xFF*color);  // Turn pixels on or off
02B4:  MOVF   x61,W
02B6:  MULLW  FF
02B8:  MOVFF  FF3,180
02BC:  CLRF   x7F
02BE:  MOVLB  0
02C0:  RCALL  0224
....................          glcd_writeByte(GLCD_RIGHT, 0xFF*color); // Turn pixels on or off
02C2:  MOVLB  1
02C4:  MOVF   x61,W
02C6:  MULLW  FF
02C8:  MOVFF  FF3,180
02CC:  MOVLW  01
02CE:  MOVWF  x7F
02D0:  MOVLB  0
02D2:  RCALL  0224
02D4:  MOVLB  1
02D6:  INCF   x63,F
02D8:  BRA    02AE
....................       }
02DA:  INCF   x62,F
02DC:  BRA    0260
....................    }
02DE:  MOVLB  0
02E0:  RETURN 0
.................... }
.................... #endif
.................... 
.................... 
.................... // Purpose:    Write a byte of data to the specified chip
.................... // Inputs:     1) chipSelect - which chip to write the data to
.................... //             2) data - the byte of data to write
.................... void glcd_writeByte(int1 side, BYTE data)
.................... {
....................    set_tris_d(0x00);
*
0224:  MOVLW  00
0226:  MOVWF  F95
....................    
....................    output_low(GLCD_RW);       // Set for writing
0228:  BCF    F92.3
022A:  BCF    F89.3
.................... 
....................     if(side)                   // Choose which side to write to
022C:  MOVLB  1
022E:  MOVF   x7F,F
0230:  BZ    0238
....................       output_high(GLCD_CS2);
0232:  BCF    F92.1
0234:  BSF    F89.1
0236:  BRA    023C
....................    else
....................       output_high(GLCD_CS1);
0238:  BCF    F92.0
023A:  BSF    F89.0
.................... 
....................     delay_us(1);
023C:  BRA    023E
.................... 
....................    output_d(data);            // Put the data on the port
023E:  CLRF   F95
0240:  MOVFF  180,F8C
....................    delay_us(1);
0244:  BRA    0246
....................    output_high(GLCD_E);       // Pulse the enable pin
0246:  BCF    F92.4
0248:  BSF    F89.4
....................    delay_us(1);
024A:  BRA    024C
....................    output_low(GLCD_E);
024C:  BCF    F92.4
024E:  BCF    F89.4
.................... 
....................    output_low(GLCD_CS1);      // Reset the chip select lines
0250:  BCF    F92.0
0252:  BCF    F89.0
....................    output_low(GLCD_CS2);
0254:  BCF    F92.1
0256:  BCF    F89.1
0258:  MOVLB  0
025A:  RETURN 0
.................... }
.................... 
.................... 
.................... // Purpose:    Reads a byte of data from the specified chip
.................... // Ouputs:     A byte of data read from the chip
.................... BYTE glcd_readByte(int1 side)
.................... {
....................    BYTE data;                 // Stores the data read from the LCD
.................... 
....................    set_tris_d(0xFF);          // Set port d to input
*
038A:  MOVLW  FF
038C:  MOVWF  F95
....................    output_high(GLCD_RW);      // Set for reading
038E:  BCF    F92.3
0390:  BSF    F89.3
.................... 
....................    if(side)                   // Choose which side to write to
0392:  MOVLB  1
0394:  MOVF   x7E,F
0396:  BZ    039E
....................       output_high(GLCD_CS2);
0398:  BCF    F92.1
039A:  BSF    F89.1
039C:  BRA    03A2
....................    else
....................       output_high(GLCD_CS1);
039E:  BCF    F92.0
03A0:  BSF    F89.0
.................... 
....................    delay_us(1);
03A2:  BRA    03A4
....................    output_high(GLCD_E);       // Pulse the enable pin
03A4:  BCF    F92.4
03A6:  BSF    F89.4
....................    delay_us(1);
03A8:  BRA    03AA
....................    data = input_d();          // Get the data from the display's output register
03AA:  SETF   F95
03AC:  MOVFF  F83,17F
....................    output_low(GLCD_E);
03B0:  BCF    F92.4
03B2:  BCF    F89.4
.................... 
....................    output_low(GLCD_CS1);      // Reset the chip select lines
03B4:  BCF    F92.0
03B6:  BCF    F89.0
....................    output_low(GLCD_CS2);
03B8:  BCF    F92.1
03BA:  BCF    F89.1
....................    return data;               // Return the read data
03BC:  MOVFF  17F,01
03C0:  MOVLB  0
03C2:  RETURN 0
.................... }
.................... 
.................... #endif
.................... 
.................... #include <graphics.c> // Libreria FUNCIONES LCD GRAFICO
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                          graphics.c                             ////
.................... ////                                                                 ////
.................... ////   This file contains functions to draw lines, rectangles, bars, ////
.................... ////   circles and text to a display. A function which draws a       ////
.................... ////   single pixel must be defined before calling the functions in  ////
.................... ////   this file. Call it glcd_pixel(x, y, color) where x is the     ////
.................... ////   horizontal coordinate, y is the vertical coordinate, and      ////
.................... ////   color is 1 bit to turn the pixel on or off.                   ////
.................... ////                                                                 ////
.................... ////   * Note: (0, 0) is treated as the upper left corner            ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... ////  glcd_line(x1, y1, x2, y2, color)                               ////
.................... ////     * Draws a line from the first point to the second point     ////
.................... ////       with the given color                                      ////
.................... ////       - color can be ON or OFF                                  ////
.................... ////                                                                 ////
.................... ////  glcd_rect(x1, y1, x2, y2, fill, color)                         ////
.................... ////     * Draws a rectangle with one corner at point (x1,y1) and    ////
.................... ////       the other corner at point (x2,y2)                         ////
.................... ////       - fill can be YES or NO                                   ////
.................... ////       - color can be ON or OFF                                  ////
.................... ////                                                                 ////
.................... ////  glcd_bar(x1, y1, x2, y2, width, color)                         ////
.................... ////     * Draws a bar (wide line) from the first point to the       ////
.................... ////       second point                                              ////
.................... ////       - width is the number of pixels wide                      ////
.................... ////       - color is ON or OFF                                      ////
.................... ////                                                                 ////
.................... ////  glcd_circle(x, y, radius, fill, color)                         ////
.................... ////     * Draws a circle with center at (x,y)                       ////
.................... ////       - fill can be YES or NO                                   ////
.................... ////       - color can be ON or OFF                                  ////
.................... ////                                                                 ////
.................... ////  glcd_text57(x, y, textptr, size, color)                        ////
.................... ////     * Write the null terminated text pointed to by textptr with ////
.................... ////       the upper left coordinate of the first character at (x,y) ////
.................... ////       Characters are 5 pixels wide and 7 pixels tall            ////
.................... ////       - size is an integer that scales the size of the text     ////
.................... ////       - color is ON or OFF                                      ////
.................... ////     * Note - This function wraps characters to the next line    ////
.................... ////              use #define GLCD_WIDTH to specify a display width  ////
.................... ////                                                                 ////
.................... //// Defines:                                                        ////
.................... ////                                                                 ////
.................... ////  LARGE_LCD                                                      ////
.................... ////     Define to indicate that LCD has more then 255 pixels in     ////
.................... ////     either the X or Y axis.  Not defined by default.            ////
.................... ////                                                                 ////
.................... ////  Required Function:                                             ////
.................... ////                                                                 ////
.................... ////     glcd_pixel(x, y, color)                                     ////
.................... ////      * Function for drawing a pixel at the specified coordinate ////
.................... ////        (x,y).  This function should be provided by the GLCD     ////
.................... ////        driver.                                                  ////
.................... ////        - color can be ON or OFF                                 ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2019 Custom Computer Services        ////
.................... //// This source code may only be used by licensed users of the CCS  ////
.................... //// C compiler.  This source code may only be distributed to other  ////
.................... //// licensed users of the CCS C compiler.  No other use,            ////
.................... //// reproduction or distribution is permitted without written       ////
.................... //// permission.  Derivative programs created using this software    ////
.................... //// in object code form are not restricted in any way.              ////
.................... ////                     http://www.ccsinfo.com                      ////
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... /////////////////////////////////////////////////////////////////////////
.................... #ifndef GRAPHICS_DRAWING_FUNCTIONS
.................... #define GRAPHICS_DRAWING_FUNCTIONS
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... /////////////////////////////////////////////////////////////////////////
.................... #ifndef ON
.................... #define ON  1
.................... #endif
.................... 
.................... #ifndef OFF
.................... #define OFF 0
.................... #endif
.................... 
.................... #ifndef YES
.................... #define YES 1
.................... #endif
.................... 
.................... #ifndef NO
.................... #define NO  0
.................... #endif
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... /////////////////////////////////////////////////////////////////////////
.................... //// Defines a 5x7 font
.................... /////////////////////////////////////////////////////////////////////////
.................... const unsigned int8 FONT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // !
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // "
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // #
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // %
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // &
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // '
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // (
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // )
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // *
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // +
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // ,
....................                          0x08, 0x08, 0x08, 0x08, 0x08, // -
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // .
....................                          0x20, 0x10, 0x08, 0x04, 0x02, // /
....................                          0x3E, 0x51, 0x49, 0x45, 0x3E, // 0
....................                          0x00, 0x04, 0x02, 0x7F, 0x00, // 1
....................                          0x42, 0x61, 0x51, 0x49, 0x46, // 2
....................                          0x22, 0x41, 0x49, 0x49, 0x36, // 3
....................                          0x18, 0x14, 0x12, 0x7F, 0x10, // 4
....................                          0x27, 0x45, 0x45, 0x45, 0x39, // 5
....................                          0x3E, 0x49, 0x49, 0x49, 0x32, // 6
....................                          0x01, 0x01, 0x71, 0x09, 0x07, // 7
....................                          0x36, 0x49, 0x49, 0x49, 0x36, // 8
....................                          0x26, 0x49, 0x49, 0x49, 0x3E, // 9
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // :
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ;
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // <
....................                          0x14, 0x14, 0x14, 0x14, 0x14, // =
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // >
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ?
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @
....................                          0x7E, 0x09, 0x09, 0x09, 0x7E, // A
....................                          0x7F, 0x49, 0x49, 0x49, 0x36, // B
....................                          0x3E, 0x41, 0x41, 0x41, 0x22, // C
....................                          0x7F, 0x41, 0x41, 0x41, 0x3E, // D
....................                          0x7F, 0x49, 0x49, 0x49, 0x41, // E
....................                          0x7F, 0x09, 0x09, 0x09, 0x01, // F
....................                          0x3E, 0x41, 0x41, 0x49, 0x3A, // G
....................                          0x7F, 0x08, 0x08, 0x08, 0x7F, // H
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I
....................                          0x30, 0x40, 0x40, 0x40, 0x3F, // J
....................                          0x7F, 0x08, 0x14, 0x22, 0x41, // K
....................                          0x7F, 0x40, 0x40, 0x40, 0x40, // L
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N
....................                          0x3E, 0x41, 0x41, 0x41, 0x3E, // O
....................                          0x7F, 0x09, 0x09, 0x09, 0x06, // P
....................                          0x1E, 0x21, 0x21, 0x21, 0x5E, // Q
....................                          0x7F, 0x09, 0x09, 0x09, 0x76};// R
.................... 
.................... const unsigned int8 FONT2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S
....................                          0x01, 0x01, 0x7F, 0x01, 0x01, // T
....................                          0x3F, 0x40, 0x40, 0x40, 0x3F, // U
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y
....................                          0x61, 0x51, 0x49, 0x45, 0x43, // Z
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ]
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^
....................                          0x40, 0x40, 0x40, 0x40, 0x40, // _
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // `
....................                          0x20, 0x54, 0x54, 0x54, 0x78, // a
....................                          0x7F, 0x44, 0x44, 0x44, 0x38, // b
....................                          0x38, 0x44, 0x44, 0x44, 0x44, // c
....................                          0x38, 0x44, 0x44, 0x44, 0x7F, // d
....................                          0x38, 0x54, 0x54, 0x54, 0x18, // e
....................                          0x04, 0x04, 0x7E, 0x05, 0x05, // f
....................                          0x08, 0x54, 0x54, 0x54, 0x3C, // g
....................                          0x7F, 0x08, 0x04, 0x04, 0x78, // h
....................                          0x00, 0x44, 0x7D, 0x40, 0x00, // i
....................                          0x20, 0x40, 0x44, 0x3D, 0x00, // j
....................                          0x7F, 0x10, 0x28, 0x44, 0x00, // k
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m
....................                          0x7C, 0x08, 0x04, 0x04, 0x78, // n
....................                          0x38, 0x44, 0x44, 0x44, 0x38, // o
....................                          0x7C, 0x14, 0x14, 0x14, 0x08, // p
....................                          0x08, 0x14, 0x14, 0x14, 0x7C, // q
....................                          0x00, 0x7C, 0x08, 0x04, 0x04, // r
....................                          0x48, 0x54, 0x54, 0x54, 0x20, // s
....................                          0x04, 0x04, 0x3F, 0x44, 0x44, // t
....................                          0x3C, 0x40, 0x40, 0x20, 0x7C, // u
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x
....................                          0x0C, 0x50, 0x50, 0x50, 0x3C, // y
....................                          0x44, 0x64, 0x54, 0x4C, 0x44, // z
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // {
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // |
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // }
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... /////////////////////////////////////////////////////////////////////////
.................... // Purpose:       Draw a line on a graphic LCD using Bresenham's
.................... //                line drawing algorithm
.................... // Inputs:        (x1, y1) - the start coordinate
.................... //                (x2, y2) - the end coordinate
.................... //                color - ON or OFF
.................... // Dependencies:  glcd_pixel()
.................... /////////////////////////////////////////////////////////////////////////
.................... #ifdef LARGE_LCD
.................... void glcd_line(unsigned int16 x1, unsigned int16 y1, unsigned int16 x2, unsigned int16 y2, int1 color)
.................... #else
.................... void glcd_line(unsigned int8 x1, unsigned int8 y1, unsigned int8 x2, unsigned int8 y2, int1 color)
.................... #endif
.................... {
....................    unsigned int16        dy, dx;
....................    signed int8  addx=1, addy=1;
....................    signed int16 P, diff;
.................... 
....................    #ifdef LARGE_LCD
....................    unsigned int16 i=0;
....................    dx = abs((signed int16)(x2 - x1));
....................    dy = abs((signed int16)(y2 - y1));
....................    #else
....................    unsigned int8 i=0;
....................    dx = abs((signed int8)(x2 - x1));
....................    dy = abs((signed int8)(y2 - y1));
....................    #endif
.................... 
....................    if(x1 > x2)
....................       addx = -1;
....................    if(y1 > y2)
....................       addy = -1;
.................... 
....................    if(dx >= dy)
....................    {
....................       dy *= 2;
....................       P = dy - dx;
....................       diff = P - dx;
.................... 
....................       for(; i<=dx; ++i)
....................       {
....................          glcd_pixel(x1, y1, color);
.................... 
....................          if(P < 0)
....................          {
....................             P  += dy;
....................             x1 += addx;
....................          }
....................          else
....................          {
....................             P  += diff;
....................             x1 += addx;
....................             y1 += addy;
....................          }
....................       }
....................    }
....................    else
....................    {
....................       dx *= 2;
....................       P = dx - dy;
....................       diff = P - dy;
.................... 
....................       for(; i<=dy; ++i)
....................       {
....................          glcd_pixel(x1, y1, color);
.................... 
....................          if(P < 0)
....................          {
....................             P  += dx;
....................             y1 += addy;
....................          }
....................          else
....................          {
....................             P  += diff;
....................             x1 += addx;
....................             y1 += addy;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... 
.................... /////////////////////////////////////////////////////////////////////////
.................... // Purpose:       Draw a rectangle on a graphic LCD
.................... // Inputs:        (x1, y1) - the start coordinate
.................... //                (x2, y2) - the end coordinate
.................... //                fill  - YES or NO
.................... //                color - ON or OFF
.................... // Dependencies:  glcd_pixel(), glcd_line()
.................... /////////////////////////////////////////////////////////////////////////
.................... #ifdef LARGE_LCD
.................... void glcd_rect(unsigned int16 x1, unsigned int16 y1, unsigned int16 x2, unsigned int16 y2, int1 fill, int1 color)
.................... #else
.................... void glcd_rect(unsigned int8 x1, unsigned int8 y1, unsigned int8 x2, unsigned int8 y2, int1 fill, int1 color)
.................... #endif
.................... {
....................    if(fill)
....................    {
....................       #ifdef LARGE_LCD
....................       unsigned int16 i, xmin, xmax, ymin, ymax;
....................       #else
....................       unsigned int8  i, xmin, xmax, ymin, ymax;
....................       #endif
.................... 
....................       if(x1 < x2)                            //  Find x min and max
....................       {
....................          xmin = x1;
....................          xmax = x2;
....................       }
....................       else
....................       {
....................          xmin = x2;
....................          xmax = x1;
....................       }
.................... 
....................       if(y1 < y2)                            // Find the y min and max
....................       {
....................          ymin = y1;
....................          ymax = y2;
....................       }
....................       else
....................       {
....................          ymin = y2;
....................          ymax = y1;
....................       }
.................... 
....................       for(; xmin <= xmax; ++xmin)
....................       {
....................          for(i=ymin; i<=ymax; ++i)
....................          {
....................             glcd_pixel(xmin, i, color);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       glcd_line(x1, y1, x2, y1, color);      // Draw the 4 sides
....................       glcd_line(x1, y2, x2, y2, color);
....................       glcd_line(x1, y1, x1, y2, color);
....................       glcd_line(x2, y1, x2, y2, color);
....................    }
.................... }
.................... 
.................... /////////////////////////////////////////////////////////////////////////
.................... // Purpose:       Draw a bar (wide line) on a graphic LCD
.................... // Inputs:        (x1, y1) - the start coordinate
.................... //                (x2, y2) - the end coordinate
.................... //                width  - The number of pixels wide
.................... //                color - ON or OFF
.................... /////////////////////////////////////////////////////////////////////////
.................... #ifdef LARGE_LCD
.................... void glcd_bar(unsigned int16 x1, unsigned int16 y1, unsigned int16 x2, unsigned int16 y2, unsigned int8 width, int1 color)
.................... #else
.................... void glcd_bar(unsigned int8 x1, unsigned int8 y1, unsigned int8 x2, unsigned int8 y2, unsigned int8 width, int1 color)
.................... #endif
.................... {
....................    unsigned int8         half_width;
....................    signed int16 dy, dx;
....................    signed int8  addx=1, addy=1, j;
....................    signed int16 P, diff, c1, c2;
.................... 
....................    #ifdef LARGE_LCD
....................    unsigned int16 i=0;
....................    dx = abs((signed int16)(x2 - x1));
....................    dy = abs((signed int16)(y2 - y1));
....................    #else
....................    unsigned int8 i=0;
....................    dx = abs((signed int8)(x2 - x1));
....................    dy = abs((signed int8)(y2 - y1));
....................    #endif
.................... 
....................    half_width = width/2;
....................    c1 = -(dx*x1 + dy*y1);
....................    c2 = -(dx*x2 + dy*y2);
.................... 
....................    if(x1 > x2)
....................    {
....................       signed int16 temp;
....................       temp = c1;
....................       c1 = c2;
....................       c2 = temp;
....................       addx = -1;
....................    }
....................    if(y1 > y2)
....................    {
....................       signed int16 temp;
....................       temp = c1;
....................       c1 = c2;
....................       c2 = temp;
....................       addy = -1;
....................    }
.................... 
....................    if(dx >= dy)
....................    {
....................       P = 2*dy - dx;
....................       diff = P - dx;
.................... 
....................       for(i=0; i<=dx; ++i)
....................       {
....................          for(j=-half_width; j<half_width+width%2; ++j)
....................          {
....................                glcd_pixel(x1, y1+j, color);
....................          }
....................          if(P < 0)
....................          {
....................             P  += 2*dy;
....................             x1 += addx;
....................          }
....................          else
....................          {
....................             P  += diff;
....................             x1 += addx;
....................             y1 += addy;
....................          }
....................       }
....................    }
....................    else
....................    {
....................       P = 2*dx - dy;
....................       diff = P - dy;
.................... 
....................       for(i=0; i<=dy; ++i)
....................       {
....................          if(P < 0)
....................          {
....................             P  += 2*dx;
....................             y1 += addy;
....................          }
....................          else
....................          {
....................             P  += diff;
....................             x1 += addx;
....................             y1 += addy;
....................          }
....................          for(j=-half_width; j<half_width+width%2; ++j)
....................          {
....................                glcd_pixel(x1+j, y1, color);
....................          }
....................       }
....................    }
.................... }
.................... 
.................... 
.................... /////////////////////////////////////////////////////////////////////////
.................... // Purpose:       Draw a circle on a graphic LCD
.................... // Inputs:        (x,y) - the center of the circle
.................... //                radius - the radius of the circle
.................... //                fill - YES or NO
.................... //                color - ON or OFF
.................... /////////////////////////////////////////////////////////////////////////
.................... #ifdef LARGE_LCD
.................... void glcd_circle(unsigned int16 x, unsigned int16 y, unsigned int16 radius, int1 fill, int1 color)
.................... #else
.................... void glcd_circle(unsigned int8 x, unsigned int8 y, unsigned int8 radius, int1 fill, int1 color)
.................... #endif
.................... {
....................    #ifdef LARGE_LCD
....................    signed int16 a, b, P;
....................    #else
....................    signed int8  a, b, P;
....................    #endif
.................... 
....................    a = 0;
....................    b = radius;
....................    P = 1 - radius;
.................... 
....................    do
....................    {
....................       if(fill)
....................       {
....................          glcd_line(x-a, y+b, x+a, y+b, color);
....................          glcd_line(x-a, y-b, x+a, y-b, color);
....................          glcd_line(x-b, y+a, x+b, y+a, color);
....................          glcd_line(x-b, y-a, x+b, y-a, color);
....................       }
....................       else
....................       {
....................          glcd_pixel(a+x, b+y, color);
....................          glcd_pixel(b+x, a+y, color);
....................          glcd_pixel(x-a, b+y, color);
....................          glcd_pixel(x-b, a+y, color);
....................          glcd_pixel(b+x, y-a, color);
....................          glcd_pixel(a+x, y-b, color);
....................          glcd_pixel(x-a, y-b, color);
....................          glcd_pixel(x-b, y-a, color);
....................       }
.................... 
....................       if(P < 0)
....................          P += 3 + 2 * a++;
....................       else
....................          P += 5 + 2 * (a++ - b--);
....................     } while(a <= b);
.................... }
.................... 
.................... 
.................... /////////////////////////////////////////////////////////////////////////
.................... // Purpose:       Write text on a graphic LCD
.................... // Inputs:        (x,y) - The upper left coordinate of the first letter
.................... //                textptr - A pointer to an array of text to display
.................... //                size - The size of the text: 1 = 5x7, 2 = 10x14, ...
.................... //                color - ON or OFF
.................... /////////////////////////////////////////////////////////////////////////
.................... #ifdef LARGE_LCD
.................... void glcd_text57(unsigned int16 x, unsigned int16 y, char* textptr, unsigned int8 size, int1 color)
.................... #else
.................... void glcd_text57(unsigned int8 x, unsigned int8 y, char* textptr, unsigned int8 size, int1 color)
.................... #endif
.................... {
....................    unsigned int8 j, k, l, m;                       // Loop counters
....................    unsigned int8 pixelData[5];                     // Stores character data
.................... 
....................    for(; *textptr != '\0'; ++textptr, ++x)// Loop through the passed string
*
04B2:  MOVFF  16A,FEA
04B6:  MOVLB  1
04B8:  MOVFF  169,FE9
04BC:  MOVF   FEF,F
04BE:  BTFSC  FD8.2
04C0:  BRA    0644
....................    {
....................       if(*textptr < 'S') // Checks if the letter is in the first font array
04C2:  MOVFF  16A,FEA
04C6:  MOVFF  169,FE9
04CA:  MOVF   FEF,W
04CC:  SUBLW  52
04CE:  BNC   0512
....................          memcpy(pixelData, FONT[*textptr - ' '], 5);
04D0:  MOVFF  16A,03
04D4:  MOVFF  169,FE9
04D8:  MOVFF  03,FEA
04DC:  MOVLW  20
04DE:  SUBWF  FEF,W
04E0:  MULLW  05
04E2:  MOVF   FF3,W
04E4:  CLRF   03
04E6:  MOVWF  x76
04E8:  MOVLW  01
04EA:  MOVWF  FEA
04EC:  MOVLW  71
04EE:  MOVWF  FE9
04F0:  CLRF   x7A
04F2:  MOVFF  176,179
04F6:  MOVLW  05
04F8:  MOVWF  01
04FA:  CLRF   FF7
04FC:  MOVF   x76,W
04FE:  MOVLB  0
0500:  RCALL  0004
0502:  TBLRD*-
0504:  TBLRD*+
0506:  MOVFF  FF5,FEE
050A:  DECFSZ 01,F
050C:  BRA    0504
050E:  BRA    056E
0510:  MOVLB  1
....................       else if(*textptr <= '~') // Check if the letter is in the second font array
0512:  MOVFF  16A,FEA
0516:  MOVFF  169,FE9
051A:  MOVF   FEF,W
051C:  SUBLW  7E
051E:  BNC   0562
....................          memcpy(pixelData, FONT2[*textptr - 'S'], 5);
0520:  MOVFF  16A,03
0524:  MOVFF  169,FE9
0528:  MOVFF  03,FEA
052C:  MOVLW  53
052E:  SUBWF  FEF,W
0530:  MULLW  05
0532:  MOVF   FF3,W
0534:  CLRF   03
0536:  MOVWF  x76
0538:  MOVLW  01
053A:  MOVWF  FEA
053C:  MOVLW  71
053E:  MOVWF  FE9
0540:  CLRF   x7A
0542:  MOVFF  176,179
0546:  MOVLW  05
0548:  MOVWF  01
054A:  CLRF   FF7
054C:  MOVF   x76,W
054E:  MOVLB  0
0550:  RCALL  0114
0552:  TBLRD*-
0554:  TBLRD*+
0556:  MOVFF  FF5,FEE
055A:  DECFSZ 01,F
055C:  BRA    0554
055E:  BRA    056E
0560:  MOVLB  1
....................       else
....................          memcpy(pixelData, FONT[0], 5);   // Default to space
0562:  CLRF   x71
0564:  CLRF   x72
0566:  CLRF   x73
0568:  CLRF   x74
056A:  CLRF   x75
056C:  MOVLB  0
.................... 
....................       // Handles newline and carriage returns
....................       switch(*textptr)
056E:  MOVFF  16A,03
0572:  MOVLB  1
0574:  MOVF   x69,W
0576:  MOVWF  FE9
0578:  MOVFF  03,FEA
057C:  MOVF   FEF,W
057E:  XORLW  0A
0580:  MOVLB  0
0582:  BZ    058A
0584:  XORLW  07
0586:  BZ    059A
0588:  BRA    05A2
....................       {
....................          case '\n':
....................             y += 7*size + 1;
058A:  MOVLB  1
058C:  MOVF   x6B,W
058E:  MULLW  07
0590:  MOVF   FF3,W
0592:  ADDLW  01
0594:  ADDWF  x68,F
....................             continue;
0596:  BRA    0636
0598:  MOVLB  0
....................          case '\r':
....................             x = 0;
059A:  MOVLB  1
059C:  CLRF   x67
....................             continue;
059E:  BRA    0636
05A0:  MOVLB  0
....................       }
.................... 
....................       if(x+5*size >= GLCD_WIDTH)          // Performs character wrapping
05A2:  MOVLB  1
05A4:  MOVF   x6B,W
05A6:  MULLW  05
05A8:  MOVF   FF3,W
05AA:  ADDWF  x67,W
05AC:  SUBLW  7F
05AE:  BC    05BC
....................       {
....................          x = 0;                           // Set x at far left position
05B0:  CLRF   x67
....................          y += 7*size + 1;                 // Set y at next position down
05B2:  MOVF   x6B,W
05B4:  MULLW  07
05B6:  MOVF   FF3,W
05B8:  ADDLW  01
05BA:  ADDWF  x68,F
....................       }
....................       for(j=0; j<5; ++j, x+=size)         // Loop through character byte data
05BC:  CLRF   x6D
05BE:  MOVF   x6D,W
05C0:  SUBLW  04
05C2:  BNC   0636
....................       {
....................          for(k=0; k < 7; ++k)             // Loop through the vertical pixels
05C4:  CLRF   x6E
05C6:  MOVF   x6E,W
05C8:  SUBLW  06
05CA:  BNC   062E
....................          {
....................             if(bit_test(pixelData[j], k)) // Check if the pixel should be set
05CC:  CLRF   03
05CE:  MOVF   x6D,W
05D0:  ADDLW  71
05D2:  MOVWF  FE9
05D4:  MOVLW  01
05D6:  ADDWFC 03,W
05D8:  MOVWF  FEA
05DA:  MOVFF  FEF,00
05DE:  MOVF   x6E,W
05E0:  MOVWF  01
05E2:  BZ    05EC
05E4:  BCF    FD8.0
05E6:  RRCF   00,F
05E8:  DECFSZ 01,F
05EA:  BRA    05E4
05EC:  BTFSS  00.0
05EE:  BRA    062A
....................             {
....................                for(l=0; l < size; ++l)    // These two loops change the
05F0:  CLRF   x6F
05F2:  MOVF   x6B,W
05F4:  SUBWF  x6F,W
05F6:  BC    062A
....................                {                          // character's size
....................                   for(m=0; m < size; ++m)
05F8:  CLRF   x70
05FA:  MOVF   x6B,W
05FC:  SUBWF  x70,W
05FE:  BC    0626
....................                   {
....................                      glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel
0600:  MOVF   x70,W
0602:  ADDWF  x67,W
0604:  MOVWF  x76
0606:  MOVF   x6E,W
0608:  MULWF  x6B
060A:  MOVF   FF3,W
060C:  ADDWF  x68,W
060E:  ADDWF  x6F,W
0610:  MOVWF  x77
0612:  MOVFF  176,178
0616:  MOVWF  x79
0618:  MOVFF  16C,17A
061C:  MOVLB  0
061E:  BRA    03C4
0620:  MOVLB  1
0622:  INCF   x70,F
0624:  BRA    05FA
....................                   }
0626:  INCF   x6F,F
0628:  BRA    05F2
....................                }
....................             }
062A:  INCF   x6E,F
062C:  BRA    05C6
....................          }
062E:  INCF   x6D,F
0630:  MOVF   x6B,W
0632:  ADDWF  x67,F
0634:  BRA    05BE
....................       }
0636:  INCF   x69,F
0638:  BTFSC  FD8.2
063A:  INCF   x6A,F
063C:  INCF   x67,F
063E:  MOVLB  0
0640:  BRA    04B2
0642:  MOVLB  1
....................    }
0644:  MOVLB  0
0646:  RETURN 0
.................... }
.................... 
.................... #endif
.................... 
.................... #define use_portb_kbd TRUE
.................... #include <kbd4x4.c> // LIBRERIA MANEJO TECLADO MATRICIAL 4X4 (tm)
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                             KBD4x4_1.C                                ////
.................... ////                  Generic keypad scan driver                       ////
.................... ////                                                                   ////
.................... ////  kbd_init()   Must be called before any other function.           ////
.................... ////                                                                   ////
.................... ////  c = kbd_getc(c)  Will return a key value if pressed or /0 if not ////
.................... ////                   This function should be called frequently so as ////
.................... ////                   not to miss a key press.                        ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... ////////////////// The following defines the keypad layout on port D
.................... 
.................... // Un-comment the following define to use port B
.................... // #define use_portb_kbd TRUE
.................... 
.................... // Make sure the port used has pull-up resistors (or the LCD) on
.................... // the column pins
.................... 
.................... 
.................... #if defined(__PCH__)
.................... #if defined use_portb_kbd
....................    #byte kbd = 0xF81                   // This puts the entire structure
.................... #else
....................    #byte kbd = 0xF83                   // This puts the entire structure
.................... #endif
.................... #else
.................... #if defined use_portb_kbd
....................    #byte kbd = 6                  // on to port B (at address 6)
.................... #else
....................    #byte kbd = 8                 // on to port D (at address 8)
.................... #endif
.................... #endif
.................... 
.................... #if defined use_portb_kbd
....................    #define set_tris_kbd(x) set_tris_b(x)
.................... #else
....................    #define set_tris_kbd(x) set_tris_d(x)
.................... #endif
.................... 
.................... 
.................... 
.................... //Keypad connection:   (for example column 0 is B2)
.................... //                Bx:
.................... 
.................... #ifdef blue_keypad  ///////////////////////////////////// For the blue keypad
.................... #define COL0 (1 << 2)
.................... #define COL1 (1 << 3)
.................... #define COL2 (1 << 6)
.................... 
.................... #define ROW0 (1 << 4)
.................... #define ROW1 (1 << 7)
.................... #define ROW2 (1 << 1)
.................... #define ROW3 (1 << 5)
.................... 
.................... #else ////////////////////////////////////////////////// For the black keypad
.................... #define COL0 (1 << 4)
.................... #define COL1 (1 << 5)
.................... #define COL2 (1 << 6)
.................... #define COL3 (1 << 7)
.................... 
.................... #define ROW0 (1 << 0)
.................... #define ROW1 (1 << 1)
.................... #define ROW2 (1 << 2)
.................... #define ROW3 (1 << 3)
.................... 
.................... #endif
.................... 
.................... #define ALL_ROWS (ROW0|ROW1|ROW2|ROW3)
.................... #define ALL_PINS (ALL_ROWS|COL0|COL1|COL2|COL3)
.................... 
.................... // Keypad layout:
.................... char const KEYS[4][4] = {{'1','2','3','A'},
....................                          {'4','5','6','B'},
....................                          {'7','8','9','C'},
....................                          {'*','0','#','D'}};
.................... 
.................... #define KBD_DEBOUNCE_FACTOR 33    // Set this number to apx n/333 where
....................                                   // n is the number of times you expect
....................                                   // to call kbd_getc each second
.................... 
.................... 
.................... void kbd_init() {
*
0220:  GOTO   1222 (RETURN)
.................... }
.................... 
.................... char kbd_getc( ) {
....................    static BYTE kbd_call_count;
....................    static int1 kbd_down;
....................    static char last_key;
....................    static BYTE col;
.................... 
....................    BYTE kchar;
....................    BYTE row;
.................... 
....................    kchar='\0';
*
0648:  MOVLB  1
064A:  CLRF   x66
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) {
064C:  INCF   04,F
064E:  MOVF   04,W
0650:  SUBLW  21
0652:  BC    070A
....................        switch (col) {
0654:  MOVF   07,W
0656:  ADDLW  FC
0658:  BC    068C
065A:  ADDLW  04
065C:  MOVLB  0
065E:  GOTO   0716
....................          case 0   : set_tris_kbd(ALL_PINS&~COL0);
0662:  MOVLW  EF
0664:  MOVWF  F93
....................                     kbd=~COL0&ALL_PINS;
0666:  MOVWF  F81
....................                     break;
0668:  MOVLB  1
066A:  BRA    068C
....................          case 1   : set_tris_kbd(ALL_PINS&~COL1);
066C:  MOVLW  DF
066E:  MOVWF  F93
....................                     kbd=~COL1&ALL_PINS;
0670:  MOVWF  F81
....................                     break;
0672:  MOVLB  1
0674:  BRA    068C
....................          case 2   : set_tris_kbd(ALL_PINS&~COL2);
0676:  MOVLW  BF
0678:  MOVWF  F93
....................                     kbd=~COL2&ALL_PINS;
067A:  MOVWF  F81
....................                     break;
067C:  MOVLB  1
067E:  BRA    068C
....................          case 3   : set_tris_kbd(ALL_PINS&~COL3);
0680:  MOVLW  7F
0682:  MOVWF  F93
....................                     kbd=~COL3&ALL_PINS;
0684:  MOVWF  F81
....................                     break;
0686:  MOVLB  1
0688:  BRA    068C
068A:  MOVLB  1
....................        }
.................... 
....................        if(kbd_down) {
068C:  BTFSS  05.0
068E:  BRA    06A2
....................          if((kbd & (ALL_ROWS))==(ALL_ROWS)) {
0690:  MOVF   F81,W
0692:  ANDLW  0F
0694:  SUBLW  0F
0696:  BNZ   06A0
....................            kbd_down=FALSE;
0698:  BCF    05.0
....................            kchar=last_key;
069A:  MOVFF  06,166
....................            last_key='\0';
069E:  CLRF   06
....................          }
....................        } else {
06A0:  BRA    0704
....................           if((kbd & (ALL_ROWS))!=(ALL_ROWS)) {
06A2:  MOVF   F81,W
06A4:  ANDLW  0F
06A6:  SUBLW  0F
06A8:  BZ    06FA
....................              if((kbd & ROW0)==0)
06AA:  MOVF   F81,W
06AC:  ANDLW  01
06AE:  BNZ   06B4
....................                row=0;
06B0:  CLRF   x67
06B2:  BRA    06D6
....................              else if((kbd & ROW1)==0)
06B4:  MOVF   F81,W
06B6:  ANDLW  02
06B8:  BNZ   06C0
....................                row=1;
06BA:  MOVLW  01
06BC:  MOVWF  x67
06BE:  BRA    06D6
....................              else if((kbd & ROW2)==0)
06C0:  MOVF   F81,W
06C2:  ANDLW  04
06C4:  BNZ   06CC
....................                row=2;
06C6:  MOVLW  02
06C8:  MOVWF  x67
06CA:  BRA    06D6
....................              else if((kbd & ROW3)==0)
06CC:  MOVF   F81,W
06CE:  ANDLW  08
06D0:  BNZ   06D6
....................                row=3;
06D2:  MOVLW  03
06D4:  MOVWF  x67
....................              last_key =KEYS[row][col];
06D6:  MOVF   x67,W
06D8:  MULLW  04
06DA:  MOVF   FF3,W
06DC:  CLRF   x69
06DE:  MOVWF  x68
06E0:  CLRF   03
06E2:  MOVF   07,W
06E4:  ADDWF  x68,W
06E6:  MOVWF  01
06E8:  MOVF   x69,W
06EA:  ADDWFC 03,F
06EC:  MOVF   01,W
06EE:  MOVLB  0
06F0:  RCALL  0200
06F2:  MOVWF  06
....................              kbd_down = TRUE;
06F4:  BSF    05.0
....................           } else {
06F6:  BRA    0706
06F8:  MOVLB  1
....................              ++col;
06FA:  INCF   07,F
....................              if(col==4)
06FC:  MOVF   07,W
06FE:  SUBLW  04
0700:  BNZ   0704
....................                col=0;
0702:  CLRF   07
0704:  MOVLB  0
....................           }
....................        }
....................       kbd_call_count=0;
0706:  CLRF   04
0708:  MOVLB  1
....................    }
....................   set_tris_kbd(ALL_PINS);
070A:  MOVLW  FF
070C:  MOVWF  F93
....................   return(kchar);
070E:  MOVFF  166,01
0712:  MOVLB  0
0714:  RETURN 0
.................... }
.................... 
.................... #include <stdio.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDIO
.................... #define _STDIO
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
0DFC:  MOVFF  128,12A
0E00:  MOVFF  127,129
0E04:  MOVFF  12A,FEA
0E08:  MOVLB  1
0E0A:  MOVFF  129,FE9
0E0E:  MOVF   FEF,F
0E10:  BZ    0E1E
0E12:  INCF   x29,F
0E14:  BTFSC  FD8.2
0E16:  INCF   x2A,F
0E18:  MOVLB  0
0E1A:  BRA    0E04
0E1C:  MOVLB  1
....................    return(sc - s);
0E1E:  MOVF   x27,W
0E20:  SUBWF  x29,W
0E22:  MOVWF  00
0E24:  MOVF   x28,W
0E26:  SUBWFB x2A,W
0E28:  MOVWF  03
0E2A:  MOVFF  00,01
0E2E:  MOVWF  02
0E30:  MOVLB  0
0E32:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #ifndef getc
.................... #define getc getch
.................... #define getchar getch
.................... #define puts(s) {printf(s); putchar(13); putchar(10);}
.................... #define putc putchar
.................... #endif
.................... /* maps error number to an error message. Writes a sequence of characters to
.................... stderr stream thus: if s is not null then string pointed to by s follwed by
.................... a colon (:) and a space and the appropriate error message returned by strerror
.................... function with argument errno
.................... 
.................... Returns: no value
.................... */
.................... 
.................... #ifdef _ERRNO
.................... void perror(char *s)
.................... {
....................   if(s)
....................   fprintf(STDERR,"%s: ",s);
....................   fprintf(STDERR,"%s\r\n",strerror(errno));
.................... }
.................... #endif
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
*
0800:  MOVLB  1
0802:  CLRF   x66
....................    sign = 0;
0804:  CLRF   x64
....................    base = 10;
0806:  MOVLW  0A
0808:  MOVWF  x65
....................    result = 0;
080A:  CLRF   x63
.................... 
....................    if (!s)
080C:  MOVF   x61,W
080E:  IORWF  x62,W
0810:  BNZ   0818
....................       return 0;
0812:  MOVLW  00
0814:  MOVWF  01
0816:  BRA    098E
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
0818:  MOVF   x66,W
081A:  INCF   x66,F
081C:  ADDWF  x61,W
081E:  MOVWF  FE9
0820:  MOVLW  00
0822:  ADDWFC x62,W
0824:  MOVWF  FEA
0826:  MOVFF  FEF,167
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
082A:  MOVF   x67,W
082C:  SUBLW  2D
082E:  BNZ   0848
....................    {
....................       sign = 1;         // Set the sign to negative
0830:  MOVLW  01
0832:  MOVWF  x64
....................       c = s[index++];
0834:  MOVF   x66,W
0836:  INCF   x66,F
0838:  ADDWF  x61,W
083A:  MOVWF  FE9
083C:  MOVLW  00
083E:  ADDWFC x62,W
0840:  MOVWF  FEA
0842:  MOVFF  FEF,167
....................    }
0846:  BRA    0860
....................    else if (c == '+')
0848:  MOVF   x67,W
084A:  SUBLW  2B
084C:  BNZ   0860
....................    {
....................       c = s[index++];
084E:  MOVF   x66,W
0850:  INCF   x66,F
0852:  ADDWF  x61,W
0854:  MOVWF  FE9
0856:  MOVLW  00
0858:  ADDWFC x62,W
085A:  MOVWF  FEA
085C:  MOVFF  FEF,167
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
0860:  MOVF   x67,W
0862:  SUBLW  2F
0864:  BTFSC  FD8.0
0866:  BRA    097E
0868:  MOVF   x67,W
086A:  SUBLW  39
086C:  BTFSS  FD8.0
086E:  BRA    097E
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
0870:  MOVF   x67,W
0872:  SUBLW  30
0874:  BNZ   08B2
0876:  MOVF   x66,W
0878:  ADDWF  x61,W
087A:  MOVWF  FE9
087C:  MOVLW  00
087E:  ADDWFC x62,W
0880:  MOVWF  FEA
0882:  MOVF   FEF,W
0884:  SUBLW  78
0886:  BZ    089A
0888:  MOVF   x66,W
088A:  ADDWF  x61,W
088C:  MOVWF  FE9
088E:  MOVLW  00
0890:  ADDWFC x62,W
0892:  MOVWF  FEA
0894:  MOVF   FEF,W
0896:  SUBLW  58
0898:  BNZ   08B2
....................       {
....................          base = 16;
089A:  MOVLW  10
089C:  MOVWF  x65
....................          index++;
089E:  INCF   x66,F
....................          c = s[index++];
08A0:  MOVF   x66,W
08A2:  INCF   x66,F
08A4:  ADDWF  x61,W
08A6:  MOVWF  FE9
08A8:  MOVLW  00
08AA:  ADDWFC x62,W
08AC:  MOVWF  FEA
08AE:  MOVFF  FEF,167
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
08B2:  MOVF   x65,W
08B4:  SUBLW  0A
08B6:  BNZ   08F0
....................       {
....................          while (c >= '0' && c <= '9')
08B8:  MOVF   x67,W
08BA:  SUBLW  2F
08BC:  BC    08EE
08BE:  MOVF   x67,W
08C0:  SUBLW  39
08C2:  BNC   08EE
....................          {
....................             result = 10*result + (c - '0');
08C4:  MOVLW  0A
08C6:  MOVWF  x68
08C8:  MOVFF  163,169
08CC:  MOVLB  0
08CE:  BRA    07B0
08D0:  MOVLW  30
08D2:  MOVLB  1
08D4:  SUBWF  x67,W
08D6:  ADDWF  01,W
08D8:  MOVWF  x63
....................             c = s[index++];
08DA:  MOVF   x66,W
08DC:  INCF   x66,F
08DE:  ADDWF  x61,W
08E0:  MOVWF  FE9
08E2:  MOVLW  00
08E4:  ADDWFC x62,W
08E6:  MOVWF  FEA
08E8:  MOVFF  FEF,167
08EC:  BRA    08B8
....................          }
....................       }
08EE:  BRA    097E
....................       else if (base == 16)    // The number is a hexa number
08F0:  MOVF   x65,W
08F2:  SUBLW  10
08F4:  BNZ   097E
....................       {
....................          c = toupper(c);
08F6:  MOVF   x67,W
08F8:  SUBLW  60
08FA:  BC    0908
08FC:  MOVF   x67,W
08FE:  SUBLW  7A
0900:  BNC   0908
0902:  MOVF   x67,W
0904:  ANDLW  DF
0906:  BRA    090A
0908:  MOVF   x67,W
090A:  MOVWF  x67
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
090C:  MOVF   x67,W
090E:  SUBLW  2F
0910:  BC    0918
0912:  MOVF   x67,W
0914:  SUBLW  39
0916:  BC    0924
0918:  MOVF   x67,W
091A:  SUBLW  40
091C:  BC    097E
091E:  MOVF   x67,W
0920:  SUBLW  46
0922:  BNC   097E
....................          {
....................             if (c >= '0' && c <= '9')
0924:  MOVF   x67,W
0926:  SUBLW  2F
0928:  BC    0942
092A:  MOVF   x67,W
092C:  SUBLW  39
092E:  BNC   0942
....................                result = (result << 4) + (c - '0');
0930:  SWAPF  x63,W
0932:  MOVWF  x68
0934:  MOVLW  F0
0936:  ANDWF  x68,F
0938:  MOVLW  30
093A:  SUBWF  x67,W
093C:  ADDWF  x68,W
093E:  MOVWF  x63
0940:  BRA    0954
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
0942:  SWAPF  x63,W
0944:  MOVWF  x68
0946:  MOVLW  F0
0948:  ANDWF  x68,F
094A:  MOVLW  41
094C:  SUBWF  x67,W
094E:  ADDLW  0A
0950:  ADDWF  x68,W
0952:  MOVWF  x63
.................... 
....................             c = s[index++];
0954:  MOVF   x66,W
0956:  INCF   x66,F
0958:  ADDWF  x61,W
095A:  MOVWF  FE9
095C:  MOVLW  00
095E:  ADDWFC x62,W
0960:  MOVWF  FEA
0962:  MOVFF  FEF,167
....................             c = toupper(c);
0966:  MOVF   x67,W
0968:  SUBLW  60
096A:  BC    0978
096C:  MOVF   x67,W
096E:  SUBLW  7A
0970:  BNC   0978
0972:  MOVF   x67,W
0974:  ANDLW  DF
0976:  BRA    097A
0978:  MOVF   x67,W
097A:  MOVWF  x67
097C:  BRA    090C
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
097E:  DECFSZ x64,W
0980:  BRA    098A
0982:  MOVF   x65,W
0984:  SUBLW  0A
0986:  BNZ   098A
....................        result = -result;
0988:  NEGF   x63
.................... 
....................    return(result);
098A:  MOVFF  163,01
098E:  MOVLB  0
0990:  GOTO   0CCA (RETURN)
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... char prueba[20];
.................... int16 numEnt;
.................... char num[20] = "";
.................... char num1, num2, num3, num4;
.................... int numU, numD, numT, numC;
.................... char choice;
.................... int8 val;
.................... char textTitle[40] = "Menu de Conversiones";
.................... char textDec[40] = "1 Dec a Bin-Oct-Hex";
.................... char textBin[40] = "2 Bin a Gray";
.................... char textGray[40] = "3 Gray a Bin";
.................... 
.................... void readInput(char *input, int maxLength) {
*
0738:  MOVLB  1
073A:  CLRF   x65
....................     char key;
....................     int index = 0;
....................     while (index < maxLength - 1) {
073C:  MOVLW  01
073E:  SUBWF  x63,W
0740:  SUBWF  x65,W
0742:  BC    079E
....................         key = kbd_getc();
0744:  MOVLB  0
0746:  RCALL  0648
0748:  MOVFF  01,164
....................         if (key != 0) {
074C:  MOVLB  1
074E:  MOVF   x64,F
0750:  BZ    079C
....................             if (key == '#') { // Assuming '#' is used to end input
0752:  MOVF   x64,W
0754:  SUBLW  23
0756:  BNZ   075A
....................                 break;
0758:  BRA    079E
....................             }
....................             if (key >= '0' && key <= '9') { // Only accept numeric characters
075A:  MOVF   x64,W
075C:  SUBLW  2F
075E:  BC    079C
0760:  MOVF   x64,W
0762:  SUBLW  39
0764:  BNC   079C
....................                 input[index++] = key;
0766:  MOVF   x65,W
0768:  INCF   x65,F
076A:  ADDWF  x61,W
076C:  MOVWF  FE9
076E:  MOVLW  00
0770:  ADDWFC x62,W
0772:  MOVWF  FEA
0774:  MOVFF  164,FEF
....................                 glcd_text57(4 + (index * 6), 32, &key, 1, on); // Display the input character
0778:  MOVF   x65,W
077A:  MULLW  06
077C:  MOVF   FF3,W
077E:  ADDLW  04
0780:  MOVWF  x66
0782:  MOVWF  x67
0784:  MOVLW  20
0786:  MOVWF  x68
0788:  MOVLW  01
078A:  MOVWF  x6A
078C:  MOVLW  64
078E:  MOVWF  x69
0790:  MOVLW  01
0792:  MOVWF  x6B
0794:  MOVWF  x6C
0796:  MOVLB  0
0798:  RCALL  04B2
079A:  MOVLB  1
....................             }
....................         }
079C:  BRA    073C
....................     }
....................     input[index] = '\0'; // Null-terminate the string
079E:  MOVF   x65,W
07A0:  ADDWF  x61,W
07A2:  MOVWF  FE9
07A4:  MOVLW  00
07A6:  ADDWFC x62,W
07A8:  MOVWF  FEA
07AA:  CLRF   FEF
07AC:  MOVLB  0
07AE:  RETURN 0
.................... }
.................... void decimal_binary(int num, char bin[]) {
*
0994:  MOVLB  1
0996:  CLRF   x64
....................     int i = 0;
....................     int j;
....................     char temp[20];
....................     
....................     if (num == 0) {
0998:  MOVF   x61,F
099A:  BNZ   09B8
....................         bin[0] = '0';
099C:  MOVFF  162,FE9
09A0:  MOVFF  163,FEA
09A4:  MOVLW  30
09A6:  MOVWF  FEF
....................         bin[1] = '\0';
09A8:  MOVLW  01
09AA:  ADDWF  x62,W
09AC:  MOVWF  FE9
09AE:  MOVLW  00
09B0:  ADDWFC x63,W
09B2:  MOVWF  FEA
09B4:  CLRF   FEF
....................         return;
09B6:  BRA    0A24
....................     }
....................     
....................     while (num > 0) {
09B8:  MOVF   x61,F
09BA:  BZ    09DA
....................         temp[i] = (num % 2) + '0';
09BC:  CLRF   03
09BE:  MOVF   x64,W
09C0:  ADDLW  66
09C2:  MOVWF  FE9
09C4:  MOVLW  01
09C6:  ADDWFC 03,W
09C8:  MOVWF  FEA
09CA:  MOVF   x61,W
09CC:  ANDLW  01
09CE:  ADDLW  30
09D0:  MOVWF  FEF
....................         num = num / 2;
09D2:  BCF    FD8.0
09D4:  RRCF   x61,F
....................         i++;
09D6:  INCF   x64,F
09D8:  BRA    09B8
....................     }
....................     
....................     // Invertir el array para obtener el binario correcto
....................     for (j = 0; j < i; j++) {
09DA:  CLRF   x65
09DC:  MOVF   x64,W
09DE:  SUBWF  x65,W
09E0:  BC    0A16
....................         bin[j] = temp[i - j - 1];
09E2:  MOVF   x65,W
09E4:  ADDWF  x62,W
09E6:  MOVWF  01
09E8:  MOVLW  00
09EA:  ADDWFC x63,W
09EC:  MOVWF  03
09EE:  MOVWF  x7B
09F0:  MOVF   x65,W
09F2:  SUBWF  x64,W
09F4:  ADDLW  FF
09F6:  CLRF   03
09F8:  ADDLW  66
09FA:  MOVWF  FE9
09FC:  MOVLW  01
09FE:  ADDWFC 03,W
0A00:  MOVWF  FEA
0A02:  MOVFF  FEF,17C
0A06:  MOVFF  17B,FEA
0A0A:  MOVFF  01,FE9
0A0E:  MOVFF  17C,FEF
0A12:  INCF   x65,F
0A14:  BRA    09DC
....................     }
....................     bin[i] = '\0';
0A16:  MOVF   x64,W
0A18:  ADDWF  x62,W
0A1A:  MOVWF  FE9
0A1C:  MOVLW  00
0A1E:  ADDWFC x63,W
0A20:  MOVWF  FEA
0A22:  CLRF   FEF
0A24:  MOVLB  0
0A26:  GOTO   0CDE (RETURN)
.................... }
.................... 
.................... void decimal_octal(int num, char oct[]) {
0A2A:  MOVLB  1
0A2C:  CLRF   x64
....................     int i = 0;
....................     int j;
....................     char temp[20];
....................     
....................     if (num == 0) {
0A2E:  MOVF   x61,F
0A30:  BNZ   0A4E
....................         oct[0] = '0';
0A32:  MOVFF  162,FE9
0A36:  MOVFF  163,FEA
0A3A:  MOVLW  30
0A3C:  MOVWF  FEF
....................         oct[1] = '\0';
0A3E:  MOVLW  01
0A40:  ADDWF  x62,W
0A42:  MOVWF  FE9
0A44:  MOVLW  00
0A46:  ADDWFC x63,W
0A48:  MOVWF  FEA
0A4A:  CLRF   FEF
....................         return;
0A4C:  BRA    0AC0
....................     }
....................     
....................     while (num > 0) {
0A4E:  MOVF   x61,F
0A50:  BZ    0A76
....................         temp[i] = (num % 8) + '0';
0A52:  CLRF   03
0A54:  MOVF   x64,W
0A56:  ADDLW  66
0A58:  MOVWF  FE9
0A5A:  MOVLW  01
0A5C:  ADDWFC 03,W
0A5E:  MOVWF  FEA
0A60:  MOVF   x61,W
0A62:  ANDLW  07
0A64:  ADDLW  30
0A66:  MOVWF  FEF
....................         num = num / 8;
0A68:  RRCF   x61,F
0A6A:  RRCF   x61,F
0A6C:  RRCF   x61,F
0A6E:  MOVLW  1F
0A70:  ANDWF  x61,F
....................         i++;
0A72:  INCF   x64,F
0A74:  BRA    0A4E
....................     }
....................     
....................     // Invertir el array para obtener el octal correcto
....................     for (j = 0; j < i; j++) {
0A76:  CLRF   x65
0A78:  MOVF   x64,W
0A7A:  SUBWF  x65,W
0A7C:  BC    0AB2
....................         oct[j] = temp[i - j - 1];
0A7E:  MOVF   x65,W
0A80:  ADDWF  x62,W
0A82:  MOVWF  01
0A84:  MOVLW  00
0A86:  ADDWFC x63,W
0A88:  MOVWF  03
0A8A:  MOVWF  x7B
0A8C:  MOVF   x65,W
0A8E:  SUBWF  x64,W
0A90:  ADDLW  FF
0A92:  CLRF   03
0A94:  ADDLW  66
0A96:  MOVWF  FE9
0A98:  MOVLW  01
0A9A:  ADDWFC 03,W
0A9C:  MOVWF  FEA
0A9E:  MOVFF  FEF,17C
0AA2:  MOVFF  17B,FEA
0AA6:  MOVFF  01,FE9
0AAA:  MOVFF  17C,FEF
0AAE:  INCF   x65,F
0AB0:  BRA    0A78
....................     }
....................     oct[i] = '\0';
0AB2:  MOVF   x64,W
0AB4:  ADDWF  x62,W
0AB6:  MOVWF  FE9
0AB8:  MOVLW  00
0ABA:  ADDWFC x63,W
0ABC:  MOVWF  FEA
0ABE:  CLRF   FEF
0AC0:  MOVLB  0
0AC2:  GOTO   0CF0 (RETURN)
.................... }
.................... 
.................... void decimal_hexadecimal(int num, char hex[]) {
0AC6:  MOVLB  1
0AC8:  CLRF   x64
....................     int i = 0;
....................     int j;
....................     char temp[20];
....................     char hex_chars[] = "0123456789ABCDEF";
0ACA:  MOVLW  30
0ACC:  MOVWF  x7A
0ACE:  MOVLW  31
0AD0:  MOVWF  x7B
0AD2:  MOVLW  32
0AD4:  MOVWF  x7C
0AD6:  MOVLW  33
0AD8:  MOVWF  x7D
0ADA:  MOVLW  34
0ADC:  MOVWF  x7E
0ADE:  MOVLW  35
0AE0:  MOVWF  x7F
0AE2:  MOVLW  36
0AE4:  MOVWF  x80
0AE6:  MOVLW  37
0AE8:  MOVWF  x81
0AEA:  MOVLW  38
0AEC:  MOVWF  x82
0AEE:  MOVLW  39
0AF0:  MOVWF  x83
0AF2:  MOVLW  41
0AF4:  MOVWF  x84
0AF6:  MOVLW  42
0AF8:  MOVWF  x85
0AFA:  MOVLW  43
0AFC:  MOVWF  x86
0AFE:  MOVLW  44
0B00:  MOVWF  x87
0B02:  MOVLW  45
0B04:  MOVWF  x88
0B06:  MOVLW  46
0B08:  MOVWF  x89
0B0A:  CLRF   x8A
....................     
....................     if (num == 0) {
0B0C:  MOVF   x61,F
0B0E:  BNZ   0B2C
....................         hex[0] = '0';
0B10:  MOVFF  162,FE9
0B14:  MOVFF  163,FEA
0B18:  MOVLW  30
0B1A:  MOVWF  FEF
....................         hex[1] = '\0';
0B1C:  MOVLW  01
0B1E:  ADDWF  x62,W
0B20:  MOVWF  FE9
0B22:  MOVLW  00
0B24:  ADDWFC x63,W
0B26:  MOVWF  FEA
0B28:  CLRF   FEF
....................         return;
0B2A:  BRA    0BB4
....................     }
....................     
....................     while (num > 0) {
0B2C:  MOVF   x61,F
0B2E:  BZ    0B6A
....................         temp[i] = hex_chars[num % 16];
0B30:  CLRF   03
0B32:  MOVF   x64,W
0B34:  ADDLW  66
0B36:  MOVWF  01
0B38:  MOVLW  01
0B3A:  ADDWFC 03,F
0B3C:  MOVFF  03,18C
0B40:  MOVF   x61,W
0B42:  ANDLW  0F
0B44:  CLRF   03
0B46:  ADDLW  7A
0B48:  MOVWF  FE9
0B4A:  MOVLW  01
0B4C:  ADDWFC 03,W
0B4E:  MOVWF  FEA
0B50:  MOVFF  FEF,18D
0B54:  MOVFF  18C,FEA
0B58:  MOVFF  01,FE9
0B5C:  MOVFF  18D,FEF
....................         num = num / 16;
0B60:  SWAPF  x61,F
0B62:  MOVLW  0F
0B64:  ANDWF  x61,F
....................         i++;
0B66:  INCF   x64,F
0B68:  BRA    0B2C
....................     }
....................     
....................     // Invertir el array para obtener el hexadecimal correcto
....................     for (j = 0; j < i; j++) {
0B6A:  CLRF   x65
0B6C:  MOVF   x64,W
0B6E:  SUBWF  x65,W
0B70:  BC    0BA6
....................         hex[j] = temp[i - j - 1];
0B72:  MOVF   x65,W
0B74:  ADDWF  x62,W
0B76:  MOVWF  01
0B78:  MOVLW  00
0B7A:  ADDWFC x63,W
0B7C:  MOVWF  03
0B7E:  MOVWF  x8C
0B80:  MOVF   x65,W
0B82:  SUBWF  x64,W
0B84:  ADDLW  FF
0B86:  CLRF   03
0B88:  ADDLW  66
0B8A:  MOVWF  FE9
0B8C:  MOVLW  01
0B8E:  ADDWFC 03,W
0B90:  MOVWF  FEA
0B92:  MOVFF  FEF,18D
0B96:  MOVFF  18C,FEA
0B9A:  MOVFF  01,FE9
0B9E:  MOVFF  18D,FEF
0BA2:  INCF   x65,F
0BA4:  BRA    0B6C
....................     }
....................     hex[i] = '\0';
0BA6:  MOVF   x64,W
0BA8:  ADDWF  x62,W
0BAA:  MOVWF  FE9
0BAC:  MOVLW  00
0BAE:  ADDWFC x63,W
0BB0:  MOVWF  FEA
0BB2:  CLRF   FEF
0BB4:  MOVLB  0
0BB6:  GOTO   0D02 (RETURN)
.................... }
.................... 
.................... void decToBinOctHex(){
....................     char input[20];
....................     char bin[20], oct[20], hex[20];
....................     const char *text1 = "Ingrese Decimal:";
*
0BE2:  MOVLW  49
0BE4:  MOVLB  1
0BE6:  MOVWF  x32
0BE8:  MOVLW  6E
0BEA:  MOVWF  x33
0BEC:  MOVLW  67
0BEE:  MOVWF  x34
0BF0:  MOVLW  72
0BF2:  MOVWF  x35
0BF4:  MOVLW  65
0BF6:  MOVWF  x36
0BF8:  MOVLW  73
0BFA:  MOVWF  x37
0BFC:  MOVLW  65
0BFE:  MOVWF  x38
0C00:  MOVLW  20
0C02:  MOVWF  x39
0C04:  MOVLW  44
0C06:  MOVWF  x3A
0C08:  MOVLW  65
0C0A:  MOVWF  x3B
0C0C:  MOVLW  63
0C0E:  MOVWF  x3C
0C10:  MOVLW  69
0C12:  MOVWF  x3D
0C14:  MOVLW  6D
0C16:  MOVWF  x3E
0C18:  MOVLW  61
0C1A:  MOVWF  x3F
0C1C:  MOVLW  6C
0C1E:  MOVWF  x40
0C20:  MOVLW  3A
0C22:  MOVWF  x41
0C24:  CLRF   x42
....................     const char *text2 = "Binario:";
0C26:  MOVLW  42
0C28:  MOVWF  x43
0C2A:  MOVLW  69
0C2C:  MOVWF  x44
0C2E:  MOVLW  6E
0C30:  MOVWF  x45
0C32:  MOVLW  61
0C34:  MOVWF  x46
0C36:  MOVLW  72
0C38:  MOVWF  x47
0C3A:  MOVLW  69
0C3C:  MOVWF  x48
0C3E:  MOVLW  6F
0C40:  MOVWF  x49
0C42:  MOVLW  3A
0C44:  MOVWF  x4A
0C46:  CLRF   x4B
....................     const char *text3 = "Octal:";
0C48:  MOVLW  4F
0C4A:  MOVWF  x4C
0C4C:  MOVLW  63
0C4E:  MOVWF  x4D
0C50:  MOVLW  74
0C52:  MOVWF  x4E
0C54:  MOVLW  61
0C56:  MOVWF  x4F
0C58:  MOVLW  6C
0C5A:  MOVWF  x50
0C5C:  MOVLW  3A
0C5E:  MOVWF  x51
0C60:  CLRF   x52
....................     const char *text4 = "Hexadecimal:";
0C62:  MOVLW  48
0C64:  MOVWF  x53
0C66:  MOVLW  65
0C68:  MOVWF  x54
0C6A:  MOVLW  78
0C6C:  MOVWF  x55
0C6E:  MOVLW  61
0C70:  MOVWF  x56
0C72:  MOVLW  64
0C74:  MOVWF  x57
0C76:  MOVLW  65
0C78:  MOVWF  x58
0C7A:  MOVLW  63
0C7C:  MOVWF  x59
0C7E:  MOVLW  69
0C80:  MOVWF  x5A
0C82:  MOVLW  6D
0C84:  MOVWF  x5B
0C86:  MOVLW  61
0C88:  MOVWF  x5C
0C8A:  MOVLW  6C
0C8C:  MOVWF  x5D
0C8E:  MOVLW  3A
0C90:  MOVWF  x5E
0C92:  CLRF   x5F
....................     
....................     glcd_text57(4, 16, text1, 1, on);
0C94:  MOVLW  04
0C96:  MOVWF  x67
0C98:  MOVLW  10
0C9A:  MOVWF  x68
0C9C:  MOVLW  01
0C9E:  MOVWF  x6A
0CA0:  MOVLW  32
0CA2:  MOVWF  x69
0CA4:  MOVLW  01
0CA6:  MOVWF  x6B
0CA8:  MOVWF  x6C
0CAA:  MOVLB  0
0CAC:  RCALL  04B2
....................     readInput(input, 20);
0CAE:  MOVLB  1
0CB0:  CLRF   x62
0CB2:  MOVLW  E2
0CB4:  MOVWF  x61
0CB6:  MOVLW  14
0CB8:  MOVWF  x63
0CBA:  MOVLB  0
0CBC:  RCALL  0738
....................     
....................     int numEnt = atoi(input); // Convertir la cadena a entero
0CBE:  MOVLB  1
0CC0:  CLRF   x62
0CC2:  MOVLW  E2
0CC4:  MOVWF  x61
0CC6:  MOVLB  0
0CC8:  BRA    0800
0CCA:  MOVFF  01,160
....................     
....................      // Convertir a binario
....................     decimal_binary(numEnt, bin);
0CCE:  MOVFF  160,161
0CD2:  MOVLB  1
0CD4:  CLRF   x63
0CD6:  MOVLW  F6
0CD8:  MOVWF  x62
0CDA:  MOVLB  0
0CDC:  BRA    0994
....................     // Convertir a octal
....................     decimal_octal(numEnt, oct);
0CDE:  MOVFF  160,161
0CE2:  MOVLW  01
0CE4:  MOVLB  1
0CE6:  MOVWF  x63
0CE8:  MOVLW  0A
0CEA:  MOVWF  x62
0CEC:  MOVLB  0
0CEE:  BRA    0A2A
....................     // Convertir a hexadecimal
....................     decimal_hexadecimal(numEnt, hex);
0CF0:  MOVFF  160,161
0CF4:  MOVLW  01
0CF6:  MOVLB  1
0CF8:  MOVWF  x63
0CFA:  MOVLW  1E
0CFC:  MOVWF  x62
0CFE:  MOVLB  0
0D00:  BRA    0AC6
....................     
....................     glcd_fillscreen(0);
0D02:  MOVLB  1
0D04:  CLRF   x61
0D06:  MOVLB  0
0D08:  CALL   025C
....................     
....................     // Mostrar las conversiones con un espaciado adecuado
....................     glcd_text57(4, 8, text2, 1, on);
0D0C:  MOVLW  04
0D0E:  MOVLB  1
0D10:  MOVWF  x67
0D12:  MOVLW  08
0D14:  MOVWF  x68
0D16:  MOVLW  01
0D18:  MOVWF  x6A
0D1A:  MOVLW  43
0D1C:  MOVWF  x69
0D1E:  MOVLW  01
0D20:  MOVWF  x6B
0D22:  MOVWF  x6C
0D24:  MOVLB  0
0D26:  CALL   04B2
....................     glcd_text57(4, 16, bin, 1, on);
0D2A:  MOVLW  04
0D2C:  MOVLB  1
0D2E:  MOVWF  x67
0D30:  MOVLW  10
0D32:  MOVWF  x68
0D34:  CLRF   x6A
0D36:  MOVLW  F6
0D38:  MOVWF  x69
0D3A:  MOVLW  01
0D3C:  MOVWF  x6B
0D3E:  MOVWF  x6C
0D40:  MOVLB  0
0D42:  CALL   04B2
....................     delay_ms(1000);
0D46:  MOVLW  04
0D48:  MOVLB  1
0D4A:  MOVWF  x61
0D4C:  MOVLW  FA
0D4E:  MOVWF  x62
0D50:  MOVLB  0
0D52:  RCALL  0BBA
0D54:  MOVLB  1
0D56:  DECFSZ x61,F
0D58:  BRA    0D4C
....................     
....................     glcd_text57(4, 24, text3, 1, on);
0D5A:  MOVLW  04
0D5C:  MOVWF  x67
0D5E:  MOVLW  18
0D60:  MOVWF  x68
0D62:  MOVLW  01
0D64:  MOVWF  x6A
0D66:  MOVLW  4C
0D68:  MOVWF  x69
0D6A:  MOVLW  01
0D6C:  MOVWF  x6B
0D6E:  MOVWF  x6C
0D70:  MOVLB  0
0D72:  CALL   04B2
....................     glcd_text57(4, 32, oct, 1, on);
0D76:  MOVLW  04
0D78:  MOVLB  1
0D7A:  MOVWF  x67
0D7C:  MOVLW  20
0D7E:  MOVWF  x68
0D80:  MOVLW  01
0D82:  MOVWF  x6A
0D84:  MOVLW  0A
0D86:  MOVWF  x69
0D88:  MOVLW  01
0D8A:  MOVWF  x6B
0D8C:  MOVWF  x6C
0D8E:  MOVLB  0
0D90:  CALL   04B2
....................     delay_ms(1000);
0D94:  MOVLW  04
0D96:  MOVLB  1
0D98:  MOVWF  x61
0D9A:  MOVLW  FA
0D9C:  MOVWF  x62
0D9E:  MOVLB  0
0DA0:  RCALL  0BBA
0DA2:  MOVLB  1
0DA4:  DECFSZ x61,F
0DA6:  BRA    0D9A
....................     
....................     glcd_text57(4, 40, text4, 1, on);
0DA8:  MOVLW  04
0DAA:  MOVWF  x67
0DAC:  MOVLW  28
0DAE:  MOVWF  x68
0DB0:  MOVLW  01
0DB2:  MOVWF  x6A
0DB4:  MOVLW  53
0DB6:  MOVWF  x69
0DB8:  MOVLW  01
0DBA:  MOVWF  x6B
0DBC:  MOVWF  x6C
0DBE:  MOVLB  0
0DC0:  CALL   04B2
....................     glcd_text57(4, 48, hex, 1, on);
0DC4:  MOVLW  04
0DC6:  MOVLB  1
0DC8:  MOVWF  x67
0DCA:  MOVLW  30
0DCC:  MOVWF  x68
0DCE:  MOVLW  01
0DD0:  MOVWF  x6A
0DD2:  MOVLW  1E
0DD4:  MOVWF  x69
0DD6:  MOVLW  01
0DD8:  MOVWF  x6B
0DDA:  MOVWF  x6C
0DDC:  MOVLB  0
0DDE:  CALL   04B2
....................     delay_ms(1000);
0DE2:  MOVLW  04
0DE4:  MOVLB  1
0DE6:  MOVWF  x61
0DE8:  MOVLW  FA
0DEA:  MOVWF  x62
0DEC:  MOVLB  0
0DEE:  RCALL  0BBA
0DF0:  MOVLB  1
0DF2:  DECFSZ x61,F
0DF4:  BRA    0DE8
0DF6:  MOVLB  0
0DF8:  GOTO   1300 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... void binaryToGray(char bin[], char gray[], int n) {
....................     gray[0] = bin[0]; // MSB of Gray code is same as that of given Binary code
*
0E34:  MOVLB  1
0E36:  MOVFF  129,01
0E3A:  MOVFF  12A,03
0E3E:  MOVFF  127,FE9
0E42:  MOVFF  128,FEA
0E46:  MOVFF  FEF,12F
0E4A:  MOVFF  03,FEA
0E4E:  MOVFF  01,FE9
0E52:  MOVFF  12F,FEF
....................     for (int i = 1; i < n; i++) {
0E56:  MOVLW  01
0E58:  MOVWF  x2C
0E5A:  MOVF   x2B,W
0E5C:  SUBWF  x2C,W
0E5E:  BC    0EAA
....................         gray[i] = (bin[i] == bin[i-1]) ? '0' : '1';
0E60:  MOVF   x2C,W
0E62:  ADDWF  x29,W
0E64:  MOVWF  01
0E66:  MOVLW  00
0E68:  ADDWFC x2A,W
0E6A:  MOVWF  03
0E6C:  MOVFF  01,12D
0E70:  MOVWF  x2E
0E72:  MOVF   x2C,W
0E74:  ADDWF  x27,W
0E76:  MOVWF  FE9
0E78:  MOVLW  00
0E7A:  ADDWFC x28,W
0E7C:  MOVWF  FEA
0E7E:  MOVFF  FEF,12F
0E82:  MOVLW  01
0E84:  SUBWF  x2C,W
0E86:  ADDWF  x27,W
0E88:  MOVWF  FE9
0E8A:  MOVLW  00
0E8C:  ADDWFC x28,W
0E8E:  MOVWF  FEA
0E90:  MOVF   FEF,W
0E92:  SUBWF  x2F,W
0E94:  BNZ   0E9A
0E96:  MOVLW  30
0E98:  BRA    0E9C
0E9A:  MOVLW  31
0E9C:  MOVFF  12E,FEA
0EA0:  MOVFF  12D,FE9
0EA4:  MOVWF  FEF
0EA6:  INCF   x2C,F
0EA8:  BRA    0E5A
....................     }
....................     gray[n] = '\0'; // Null-terminate the string
0EAA:  MOVF   x2B,W
0EAC:  ADDWF  x29,W
0EAE:  MOVWF  FE9
0EB0:  MOVLW  00
0EB2:  ADDWFC x2A,W
0EB4:  MOVWF  FEA
0EB6:  CLRF   FEF
0EB8:  MOVLB  0
0EBA:  GOTO   0F80 (RETURN)
.................... }
.................... 
.................... void grayToBinary(char gray[], char bin[], int n) {
....................     bin[0] = gray[0]; // MSB of Binary code is same as that of given Gray code
*
0FC8:  MOVLB  1
0FCA:  MOVFF  128,01
0FCE:  MOVFF  129,03
0FD2:  MOVFF  126,FE9
0FD6:  MOVFF  127,FEA
0FDA:  MOVFF  FEF,12E
0FDE:  MOVFF  03,FEA
0FE2:  MOVFF  01,FE9
0FE6:  MOVFF  12E,FEF
....................     for (int i = 1; i < n; i++) {
0FEA:  MOVLW  01
0FEC:  MOVWF  x2B
0FEE:  MOVF   x2A,W
0FF0:  SUBWF  x2B,W
0FF2:  BC    1052
....................         bin[i] = (gray[i] == '0') ? bin[i-1] : (bin[i-1] == '0' ? '1' : '0');
0FF4:  MOVF   x2B,W
0FF6:  ADDWF  x28,W
0FF8:  MOVWF  01
0FFA:  MOVLW  00
0FFC:  ADDWFC x29,W
0FFE:  MOVWF  03
1000:  MOVFF  01,12C
1004:  MOVWF  x2D
1006:  MOVF   x2B,W
1008:  ADDWF  x26,W
100A:  MOVWF  FE9
100C:  MOVLW  00
100E:  ADDWFC x27,W
1010:  MOVWF  FEA
1012:  MOVF   FEF,W
1014:  SUBLW  30
1016:  BNZ   102A
1018:  MOVLW  01
101A:  SUBWF  x2B,W
101C:  ADDWF  x28,W
101E:  MOVWF  FE9
1020:  MOVLW  00
1022:  ADDWFC x29,W
1024:  MOVWF  FEA
1026:  MOVF   FEF,W
1028:  BRA    1044
102A:  MOVLW  01
102C:  SUBWF  x2B,W
102E:  ADDWF  x28,W
1030:  MOVWF  FE9
1032:  MOVLW  00
1034:  ADDWFC x29,W
1036:  MOVWF  FEA
1038:  MOVF   FEF,W
103A:  SUBLW  30
103C:  BNZ   1042
103E:  MOVLW  31
1040:  BRA    1044
1042:  MOVLW  30
1044:  MOVFF  12D,FEA
1048:  MOVFF  12C,FE9
104C:  MOVWF  FEF
104E:  INCF   x2B,F
1050:  BRA    0FEE
....................     }
....................     bin[n] = '\0'; // Null-terminate the string
1052:  MOVF   x2A,W
1054:  ADDWF  x28,W
1056:  MOVWF  FE9
1058:  MOVLW  00
105A:  ADDWFC x29,W
105C:  MOVWF  FEA
105E:  CLRF   FEF
1060:  MOVLB  0
1062:  GOTO   1124 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... void convertBinToGray() {
....................     char bin[20], gray[20];
....................     const char *text1 = "Ingrese Binario:";
*
0EBE:  MOVLW  49
0EC0:  MOVLB  1
0EC2:  MOVWF  x0A
0EC4:  MOVLW  6E
0EC6:  MOVWF  x0B
0EC8:  MOVLW  67
0ECA:  MOVWF  x0C
0ECC:  MOVLW  72
0ECE:  MOVWF  x0D
0ED0:  MOVLW  65
0ED2:  MOVWF  x0E
0ED4:  MOVLW  73
0ED6:  MOVWF  x0F
0ED8:  MOVLW  65
0EDA:  MOVWF  x10
0EDC:  MOVLW  20
0EDE:  MOVWF  x11
0EE0:  MOVLW  42
0EE2:  MOVWF  x12
0EE4:  MOVLW  69
0EE6:  MOVWF  x13
0EE8:  MOVLW  6E
0EEA:  MOVWF  x14
0EEC:  MOVLW  61
0EEE:  MOVWF  x15
0EF0:  MOVLW  72
0EF2:  MOVWF  x16
0EF4:  MOVLW  69
0EF6:  MOVWF  x17
0EF8:  MOVLW  6F
0EFA:  MOVWF  x18
0EFC:  MOVLW  3A
0EFE:  MOVWF  x19
0F00:  CLRF   x1A
....................     const char *text2 = "Gray Code:";
0F02:  MOVLW  47
0F04:  MOVWF  x1B
0F06:  MOVLW  72
0F08:  MOVWF  x1C
0F0A:  MOVLW  61
0F0C:  MOVWF  x1D
0F0E:  MOVLW  79
0F10:  MOVWF  x1E
0F12:  MOVLW  20
0F14:  MOVWF  x1F
0F16:  MOVLW  43
0F18:  MOVWF  x20
0F1A:  MOVLW  6F
0F1C:  MOVWF  x21
0F1E:  MOVLW  64
0F20:  MOVWF  x22
0F22:  MOVLW  65
0F24:  MOVWF  x23
0F26:  MOVLW  3A
0F28:  MOVWF  x24
0F2A:  CLRF   x25
....................     
....................     glcd_text57(4, 16, text1, 1, on);
0F2C:  MOVLW  04
0F2E:  MOVWF  x67
0F30:  MOVLW  10
0F32:  MOVWF  x68
0F34:  MOVLW  01
0F36:  MOVWF  x6A
0F38:  MOVLW  0A
0F3A:  MOVWF  x69
0F3C:  MOVLW  01
0F3E:  MOVWF  x6B
0F40:  MOVWF  x6C
0F42:  MOVLB  0
0F44:  CALL   04B2
....................     readInput(bin, 20);
0F48:  MOVLB  1
0F4A:  CLRF   x62
0F4C:  MOVLW  E2
0F4E:  MOVWF  x61
0F50:  MOVLW  14
0F52:  MOVWF  x63
0F54:  MOVLB  0
0F56:  CALL   0738
....................     
....................     int n = strlen(bin);
0F5A:  MOVLB  1
0F5C:  CLRF   x28
0F5E:  MOVLW  E2
0F60:  MOVWF  x27
0F62:  MOVLB  0
0F64:  RCALL  0DFC
0F66:  MOVFF  01,126
....................     binaryToGray(bin, gray, n);
0F6A:  MOVLB  1
0F6C:  CLRF   x28
0F6E:  MOVLW  E2
0F70:  MOVWF  x27
0F72:  CLRF   x2A
0F74:  MOVLW  F6
0F76:  MOVWF  x29
0F78:  MOVFF  126,12B
0F7C:  MOVLB  0
0F7E:  BRA    0E34
....................     
....................     glcd_fillscreen(0);
0F80:  MOVLB  1
0F82:  CLRF   x61
0F84:  MOVLB  0
0F86:  CALL   025C
....................     glcd_text57(4, 8, text2, 1, on);
0F8A:  MOVLW  04
0F8C:  MOVLB  1
0F8E:  MOVWF  x67
0F90:  MOVLW  08
0F92:  MOVWF  x68
0F94:  MOVLW  01
0F96:  MOVWF  x6A
0F98:  MOVLW  1B
0F9A:  MOVWF  x69
0F9C:  MOVLW  01
0F9E:  MOVWF  x6B
0FA0:  MOVWF  x6C
0FA2:  MOVLB  0
0FA4:  CALL   04B2
....................     glcd_text57(4, 16, gray, 1, on);
0FA8:  MOVLW  04
0FAA:  MOVLB  1
0FAC:  MOVWF  x67
0FAE:  MOVLW  10
0FB0:  MOVWF  x68
0FB2:  CLRF   x6A
0FB4:  MOVLW  F6
0FB6:  MOVWF  x69
0FB8:  MOVLW  01
0FBA:  MOVWF  x6B
0FBC:  MOVWF  x6C
0FBE:  MOVLB  0
0FC0:  CALL   04B2
0FC4:  GOTO   133A (RETURN)
.................... }
.................... 
.................... void convertGrayToBin() {
....................     char gray[20], bin[20];
....................     const char *text3 = "Ingrese Gray:";
*
1066:  MOVLW  49
1068:  MOVLB  1
106A:  MOVWF  x0A
106C:  MOVLW  6E
106E:  MOVWF  x0B
1070:  MOVLW  67
1072:  MOVWF  x0C
1074:  MOVLW  72
1076:  MOVWF  x0D
1078:  MOVLW  65
107A:  MOVWF  x0E
107C:  MOVLW  73
107E:  MOVWF  x0F
1080:  MOVLW  65
1082:  MOVWF  x10
1084:  MOVLW  20
1086:  MOVWF  x11
1088:  MOVLW  47
108A:  MOVWF  x12
108C:  MOVLW  72
108E:  MOVWF  x13
1090:  MOVLW  61
1092:  MOVWF  x14
1094:  MOVLW  79
1096:  MOVWF  x15
1098:  MOVLW  3A
109A:  MOVWF  x16
109C:  CLRF   x17
....................     const char *text4 = "Binary Code:";
109E:  MOVLW  42
10A0:  MOVWF  x18
10A2:  MOVLW  69
10A4:  MOVWF  x19
10A6:  MOVLW  6E
10A8:  MOVWF  x1A
10AA:  MOVLW  61
10AC:  MOVWF  x1B
10AE:  MOVLW  72
10B0:  MOVWF  x1C
10B2:  MOVLW  79
10B4:  MOVWF  x1D
10B6:  MOVLW  20
10B8:  MOVWF  x1E
10BA:  MOVLW  43
10BC:  MOVWF  x1F
10BE:  MOVLW  6F
10C0:  MOVWF  x20
10C2:  MOVLW  64
10C4:  MOVWF  x21
10C6:  MOVLW  65
10C8:  MOVWF  x22
10CA:  MOVLW  3A
10CC:  MOVWF  x23
10CE:  CLRF   x24
....................     
....................     glcd_text57(4, 16, text3, 1, on);
10D0:  MOVLW  04
10D2:  MOVWF  x67
10D4:  MOVLW  10
10D6:  MOVWF  x68
10D8:  MOVLW  01
10DA:  MOVWF  x6A
10DC:  MOVLW  0A
10DE:  MOVWF  x69
10E0:  MOVLW  01
10E2:  MOVWF  x6B
10E4:  MOVWF  x6C
10E6:  MOVLB  0
10E8:  CALL   04B2
....................     readInput(gray, 20);
10EC:  MOVLB  1
10EE:  CLRF   x62
10F0:  MOVLW  E2
10F2:  MOVWF  x61
10F4:  MOVLW  14
10F6:  MOVWF  x63
10F8:  MOVLB  0
10FA:  CALL   0738
....................     
....................     int n = strlen(gray);
10FE:  MOVLB  1
1100:  CLRF   x28
1102:  MOVLW  E2
1104:  MOVWF  x27
1106:  MOVLB  0
1108:  RCALL  0DFC
110A:  MOVFF  01,125
....................     grayToBinary(gray, bin, n);
110E:  MOVLB  1
1110:  CLRF   x27
1112:  MOVLW  E2
1114:  MOVWF  x26
1116:  CLRF   x29
1118:  MOVLW  F6
111A:  MOVWF  x28
111C:  MOVFF  125,12A
1120:  MOVLB  0
1122:  BRA    0FC8
....................     
....................     glcd_fillscreen(0);
1124:  MOVLB  1
1126:  CLRF   x61
1128:  MOVLB  0
112A:  CALL   025C
....................     glcd_text57(4, 8, text4, 1, on);
112E:  MOVLW  04
1130:  MOVLB  1
1132:  MOVWF  x67
1134:  MOVLW  08
1136:  MOVWF  x68
1138:  MOVLW  01
113A:  MOVWF  x6A
113C:  MOVLW  18
113E:  MOVWF  x69
1140:  MOVLW  01
1142:  MOVWF  x6B
1144:  MOVWF  x6C
1146:  MOVLB  0
1148:  CALL   04B2
....................     glcd_text57(4, 16, bin, 1, on);
114C:  MOVLW  04
114E:  MOVLB  1
1150:  MOVWF  x67
1152:  MOVLW  10
1154:  MOVWF  x68
1156:  CLRF   x6A
1158:  MOVLW  F6
115A:  MOVWF  x69
115C:  MOVLW  01
115E:  MOVWF  x6B
1160:  MOVWF  x6C
1162:  MOVLB  0
1164:  CALL   04B2
1168:  GOTO   1374 (RETURN)
.................... }
.................... 
.................... void main(){
116C:  CLRF   FF8
116E:  BCF    FD0.7
1170:  MOVF   FC1,W
1172:  ANDLW  C0
1174:  IORLW  0F
1176:  MOVWF  FC1
1178:  MOVLW  07
117A:  MOVWF  FB4
117C:  BCF    05.0
117E:  BRA    11E0
1180:  DATA 01,00
1182:  DATA 04,00
1184:  DATA 04,00
1186:  DATA 06,00
1188:  DATA 00,00
118A:  DATA 00,01
118C:  DATA 00,24
118E:  DATA 00,15
1190:  DATA 00,42
1192:  DATA 4D,65
1194:  DATA 6E,75
1196:  DATA 20,64
1198:  DATA 65,20
119A:  DATA 43,6F
119C:  DATA 6E,76
119E:  DATA 65,72
11A0:  DATA 73,69
11A2:  DATA 6F,6E
11A4:  DATA 65,73
11A6:  DATA 00,14
11A8:  DATA 00,6A
11AA:  DATA 31,20
11AC:  DATA 44,65
11AE:  DATA 63,20
11B0:  DATA 61,20
11B2:  DATA 42,69
11B4:  DATA 6E,2D
11B6:  DATA 4F,63
11B8:  DATA 74,2D
11BA:  DATA 48,65
11BC:  DATA 78,00
11BE:  DATA 0D,00
11C0:  DATA 92,32
11C2:  DATA 20,42
11C4:  DATA 69,6E
11C6:  DATA 20,61
11C8:  DATA 20,47
11CA:  DATA 72,61
11CC:  DATA 79,00
11CE:  DATA 0D,00
11D0:  DATA BA,33
11D2:  DATA 20,47
11D4:  DATA 72,61
11D6:  DATA 79,20
11D8:  DATA 61,20
11DA:  DATA 42,69
11DC:  DATA 6E,00
11DE:  DATA 00,00
11E0:  MOVLW  00
11E2:  MOVWF  FF8
11E4:  MOVLW  11
11E6:  MOVWF  FF7
11E8:  MOVLW  80
11EA:  MOVWF  FF6
11EC:  TBLRD*+
11EE:  MOVF   FF5,W
11F0:  MOVWF  00
11F2:  XORLW  00
11F4:  BZ    121C
11F6:  TBLRD*+
11F8:  MOVF   FF5,W
11FA:  MOVWF  01
11FC:  BTFSC  FE8.7
11FE:  BRA    120A
1200:  ANDLW  3F
1202:  MOVWF  FEA
1204:  TBLRD*+
1206:  MOVFF  FF5,FE9
120A:  BTFSC  01.6
120C:  TBLRD*+
120E:  BTFSS  01.6
1210:  TBLRD*+
1212:  MOVFF  FF5,FEE
1216:  DCFSNZ 00,F
1218:  BRA    11EC
121A:  BRA    120E
121C:  CLRF   FF8
....................    kbd_init(); // Inicia el tm
121E:  GOTO   0220
....................    glcd_init(on); // inicia el lcdg
1222:  MOVLW  01
1224:  MOVWF  xE2
1226:  GOTO   02E2
....................    glcd_fillscreen(0); //limpia el lcdg
122A:  MOVLB  1
122C:  CLRF   x61
122E:  MOVLB  0
1230:  CALL   025C
....................    choice = 0;
1234:  CLRF   40
....................    val = 0;
1236:  CLRF   41
....................    
....................    while(true){
....................       
....................       
....................       
....................       num1 = 0;
1238:  CLRF   38
....................       num2 = 0;
123A:  CLRF   39
....................       num3 = 0;
123C:  CLRF   3A
....................       num4 = 0;
123E:  CLRF   3B
....................       choice = 0;
1240:  CLRF   40
....................       glcd_fillscreen(0); //limpia el lcdg
1242:  MOVLB  1
1244:  CLRF   x61
1246:  MOVLB  0
1248:  CALL   025C
....................       glcd_text57(0,0,textTitle,1,on);
124C:  MOVLB  1
124E:  CLRF   x67
1250:  CLRF   x68
1252:  CLRF   x6A
1254:  MOVLW  42
1256:  MOVWF  x69
1258:  MOVLW  01
125A:  MOVWF  x6B
125C:  MOVWF  x6C
125E:  MOVLB  0
1260:  CALL   04B2
....................       glcd_text57(4,16,textDec,1,on);
1264:  MOVLW  04
1266:  MOVLB  1
1268:  MOVWF  x67
126A:  MOVLW  10
126C:  MOVWF  x68
126E:  CLRF   x6A
1270:  MOVLW  6A
1272:  MOVWF  x69
1274:  MOVLW  01
1276:  MOVWF  x6B
1278:  MOVWF  x6C
127A:  MOVLB  0
127C:  CALL   04B2
....................       glcd_text57(4,32,textBin,1,on);
1280:  MOVLW  04
1282:  MOVLB  1
1284:  MOVWF  x67
1286:  MOVLW  20
1288:  MOVWF  x68
128A:  CLRF   x6A
128C:  MOVLW  92
128E:  MOVWF  x69
1290:  MOVLW  01
1292:  MOVWF  x6B
1294:  MOVWF  x6C
1296:  MOVLB  0
1298:  CALL   04B2
....................       glcd_text57(4,50,textGray,1,on);
129C:  MOVLW  04
129E:  MOVLB  1
12A0:  MOVWF  x67
12A2:  MOVLW  32
12A4:  MOVWF  x68
12A6:  CLRF   x6A
12A8:  MOVLW  BA
12AA:  MOVWF  x69
12AC:  MOVLW  01
12AE:  MOVWF  x6B
12B0:  MOVWF  x6C
12B2:  MOVLB  0
12B4:  CALL   04B2
....................       do{
....................       choice = kbd_getc();
12B8:  CALL   0648
12BC:  MOVFF  01,40
....................       } while(choice==0);
12C0:  MOVF   40,F
12C2:  BZ    12B8
....................       //glcd_fillscreen(0);
....................       val=choice-48;
12C4:  MOVLW  30
12C6:  SUBWF  40,W
12C8:  MOVWF  41
....................       //glcd_text57(4,4,val,1,on);
....................       //delay_ms(1000);
....................       
....................       switch (val) {
12CA:  MOVF   41,W
12CC:  XORLW  01
12CE:  BZ    12DA
12D0:  XORLW  03
12D2:  BZ    1314
12D4:  XORLW  01
12D6:  BZ    134E
12D8:  BRA    1386
....................             case 1:
....................             glcd_fillscreen(0);
12DA:  MOVLB  1
12DC:  CLRF   x61
12DE:  MOVLB  0
12E0:  CALL   025C
....................                glcd_text57(4,4,textDec,1,on);
12E4:  MOVLW  04
12E6:  MOVLB  1
12E8:  MOVWF  x67
12EA:  MOVWF  x68
12EC:  CLRF   x6A
12EE:  MOVLW  6A
12F0:  MOVWF  x69
12F2:  MOVLW  01
12F4:  MOVWF  x6B
12F6:  MOVWF  x6C
12F8:  MOVLB  0
12FA:  CALL   04B2
....................                decToBinOctHex();
12FE:  BRA    0BE2
....................                delay_ms(1000);
1300:  MOVLW  04
1302:  MOVWF  xE2
1304:  MOVLW  FA
1306:  MOVLB  1
1308:  MOVWF  x62
130A:  MOVLB  0
130C:  RCALL  0BBA
130E:  DECFSZ xE2,F
1310:  BRA    1304
....................                 break;
1312:  BRA    1386
....................             case 2:
....................             glcd_fillscreen(0);
1314:  MOVLB  1
1316:  CLRF   x61
1318:  MOVLB  0
131A:  CALL   025C
....................                 glcd_text57(4, 4, textBin, 1, on);
131E:  MOVLW  04
1320:  MOVLB  1
1322:  MOVWF  x67
1324:  MOVWF  x68
1326:  CLRF   x6A
1328:  MOVLW  92
132A:  MOVWF  x69
132C:  MOVLW  01
132E:  MOVWF  x6B
1330:  MOVWF  x6C
1332:  MOVLB  0
1334:  CALL   04B2
....................                 convertBinToGray();
1338:  BRA    0EBE
....................                 delay_ms(1000);
133A:  MOVLW  04
133C:  MOVWF  xE2
133E:  MOVLW  FA
1340:  MOVLB  1
1342:  MOVWF  x62
1344:  MOVLB  0
1346:  RCALL  0BBA
1348:  DECFSZ xE2,F
134A:  BRA    133E
....................                 break;
134C:  BRA    1386
....................             case 3:
....................             glcd_fillscreen(0);
134E:  MOVLB  1
1350:  CLRF   x61
1352:  MOVLB  0
1354:  CALL   025C
....................                 glcd_text57(4,4,textGray,1,on);
1358:  MOVLW  04
135A:  MOVLB  1
135C:  MOVWF  x67
135E:  MOVWF  x68
1360:  CLRF   x6A
1362:  MOVLW  BA
1364:  MOVWF  x69
1366:  MOVLW  01
1368:  MOVWF  x6B
136A:  MOVWF  x6C
136C:  MOVLB  0
136E:  CALL   04B2
....................                 convertGrayToBin();
1372:  BRA    1066
....................                 delay_ms(1000);
1374:  MOVLW  04
1376:  MOVWF  xE2
1378:  MOVLW  FA
137A:  MOVLB  1
137C:  MOVWF  x62
137E:  MOVLB  0
1380:  RCALL  0BBA
1382:  DECFSZ xE2,F
1384:  BRA    1378
....................                 break;
....................         }
1386:  BRA    1238
....................       
....................    }
.................... }
1388:  SLEEP 

Configuration Fuses:
   Word  1: CF3F   PLL12 CPUDIV4 USBDIV FCMEN IESO
   Word  2: 1E26   PUT BROWNOUT VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
